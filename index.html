<!DOCTYPE html>
<!-- Version: 1.5.0 - Updated 2025-08-17 - Fixed RLGL with 40s timer and more boxes -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="version" content="1.5.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Alpha Games</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            color: #fff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #gameCanvas {
            background: #000;
            cursor: crosshair;
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .contestant-number {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5rem;
            font-weight: 900;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }

        .timer-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 2rem;
            font-weight: 900;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
        }

        .game-status {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: 900;
            text-align: center;
            text-shadow: 0 0 20px currentColor;
            pointer-events: none;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            text-align: center;
            opacity: 0.9;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .death-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ff0000;
            opacity: 0;
            pointer-events: none;
            z-index: 999;
            transition: opacity 0.1s;
        }

        .death-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 1000;
            display: none;
        }

        .death-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Overlays -->
    <div class="ui-overlay">
        <div class="contestant-number" id="contestantNumber">Contestant #67</div>
        <div class="timer-display" id="timerDisplay"></div>
        <div class="game-status" id="gameStatus"></div>
        <div class="instructions" id="instructions"></div>
        <div class="death-flash" id="deathFlash"></div>
        <div class="death-video" id="deathVideoContainer">
            <video id="deathVideo" preload="auto" muted>
                <source src="audio/Delete_Button.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
        </div>
    </div>

    <script>
        // Game Engine Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let audioContext;

        // Make canvas full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Initial resize and add event listener
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Initialize audio context on first user interaction
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Background music system with scene-specific tracks
        let musicTracks = {};
        let currentMusic = null;
        let musicEnabled = true;

        function loadBackgroundMusic() {
            console.log('ðŸŽµ Loading scene-specific background music...');
            
            // Load different tracks for different scenes
            const tracks = [
                { scene: 'honeycomb', file: 'audio/chris.mp3', name: 'Chris Theme' },
                { scene: 'glassBridge', file: 'audio/finalsong.mp3', name: 'Final Song' },
                { scene: 'marbles', file: 'audio/marblesong.mp3', name: 'Marbles Theme' },
                { scene: 'intro', file: 'audio/introsong.mp3', name: 'Intro Theme' },
                { scene: 'redLightGreenLight', file: 'audio/background-music.mp3', name: 'Red Light Green Light Theme' },
                { scene: 'main', file: 'audio/introsong.mp3', name: 'Main Theme' }
            ];
            
            tracks.forEach(track => {
                const audio = new Audio();
                if (audio.canPlayType('audio/mpeg')) {
                    // Use absolute path for Vercel deployment
                    const path = track.file.startsWith('/') ? track.file : '/' + track.file;
                    audio.src = path;
                    audio.loop = true;
                    audio.volume = 0.4; // Slightly higher for scene-specific music
                    
                    // Handle successful loading
                    audio.addEventListener('canplaythrough', () => {
                        console.log(`âœ… ${track.name} loaded successfully from ${path}`);
                    });
                    
                    // Handle loading errors gracefully
                    audio.addEventListener('error', (e) => {
                        console.log(`âŒ ${track.name} failed to load from ${path}. Game will continue without music.`);
                    });
                    
                    musicTracks[track.scene] = audio;
                }
            });
        }

        function playSceneMusic(sceneName) {
            console.log(`ðŸŽµ playSceneMusic called for: ${sceneName}`);
            if (!musicEnabled) return;
            
            // Stop current music completely
            if (currentMusic) {
                currentMusic.pause();
                currentMusic.currentTime = 0;
                currentMusic = null; // Clear the reference!
                console.log('ðŸŽµ Stopped previous music');
            }
            
            // Play scene-specific music
            const track = musicTracks[sceneName] || musicTracks['main'];
            console.log(`ðŸŽµ Track found for ${sceneName}:`, track ? 'YES' : 'NO');
            if (track && track.readyState >= 2) {
                currentMusic = track;
                track.play().catch(err => {
                    console.log(`ðŸŽµ Music autoplay prevented for ${sceneName}:`, err);
                });
                console.log(`ðŸŽµ Now playing: ${sceneName} theme`);
            } else if (track) {
                console.log(`ðŸŽµ Track not ready yet for ${sceneName}, readyState:`, track.readyState);
            }
        }

        function stopBackgroundMusic() {
            console.log('ðŸŽµ stopBackgroundMusic called');
            
            // Stop current music
            if (currentMusic) {
                console.log('ðŸŽµ Stopping music:', currentMusic.src);
                currentMusic.pause();
                currentMusic.currentTime = 0;
                currentMusic = null;
                console.log('ðŸŽµ Music stopped and cleared');
            }
            
            // Extra safety: Stop all music tracks to prevent overlapping
            Object.keys(musicTracks).forEach(scene => {
                const track = musicTracks[scene];
                if (track && !track.paused) {
                    track.pause();
                    track.currentTime = 0;
                    console.log(`ðŸŽµ Force stopped ${scene} track`);
                }
            });
        }

        // Legacy function for compatibility
        function playBackgroundMusic() {
            playSceneMusic('main');
        }

        // Game State
        let currentScene = 'mainMenu';
        let gameTimer = 30; // Default 30 second timer
        let assets = {};
        
        // Leaderboard System
        function saveLeaderboard(leaderboard) {
            try {
                localStorage.setItem('alphaGamesLeaderboard', JSON.stringify(leaderboard));
                console.log('ðŸ† Leaderboard saved to localStorage');
            } catch (e) {
                console.error('Failed to save leaderboard:', e);
            }
        }
        
        function loadLeaderboard() {
            try {
                const saved = localStorage.getItem('alphaGamesLeaderboard');
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                console.error('Failed to load leaderboard:', e);
                return [];
            }
        }
        
        function addToLeaderboard(playerName, completionTime) {
            const leaderboard = loadLeaderboard();
            const entry = {
                name: playerName,
                time: completionTime,
                date: new Date().toISOString(),
                timestamp: Date.now()
            };
            
            leaderboard.push(entry);
            // Sort by completion time (fastest first)
            leaderboard.sort((a, b) => a.time - b.time);
            // Keep only top 10
            if (leaderboard.length > 10) {
                leaderboard.splice(10);
            }
            
            saveLeaderboard(leaderboard);
            return leaderboard;
        }
        
        function downloadLeaderboardJSON() {
            const leaderboard = loadLeaderboard();
            const dataStr = JSON.stringify(leaderboard, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `alpha-games-leaderboard-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            console.log('ðŸ“ Leaderboard JSON downloaded');
        }
        
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            return `${minutes}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        }
        
        function startLeaderboardTimer() {
            if (!gameState.gameStartTime) {
                gameState.gameStartTime = Date.now();
                console.log('â±ï¸ Leaderboard timer started!');
            }
        }
        
        function calculateGameTime() {
            if (gameState.gameStartTime) {
                gameState.totalGameTime = (Date.now() - gameState.gameStartTime) / 1000;
                console.log(`ðŸ Total game time: ${formatTime(gameState.totalGameTime)}`);
                return gameState.totalGameTime;
            }
            return 0;
        }
        let gameState = {
            playerPosition: { x: 100, y: 700 },
            isMoving: false,
            movementKeys: new Set(), // Track which movement keys are currently pressed
            isGreenLight: true,
            isWarningFlash: false, // Red flash warning before red light
            isDarkFlash: false, // Darkness effect in cookie game
            honeycombProgress: [],
            bridgePosition: { row: 0, col: 0 },
            safeTiles: [],
            mousePos: { x: 0, y: 0 },
            keys: {},
            moneyCounter: 0, // Debt from tuition counter
            introStage: 0,
            mainMenuMusicTimeout: null, // Track main menu music timeout
            horrorAudioTimeouts: [], // Track horror audio timeouts
            scanning: false, // Visual scanning effect active
            scanProgress: 0, // Progress of scanning sweep (0 to 1)
            // Obstacle system for Red Light Green Light
            obstacles: [], // Array of obstacle objects
            obstaclesInitialized: false, // Track if obstacles are set up
            honeycombComplete: false,
            tracingActive: false,
            onBridge: false,
            cookieOutlines: {}, // Store extracted PNG outlines
            // Money falling transition effect
            fallingMoney: [],
            isMoneyFalling: false,
            isPaused: false, // Game pause during money falling
            nextSceneAfterMoney: '', // Scene to go to after money finishes
            lightFlicker: 0, // Glass Bridge flickering lights
            redLightCheckInterval: null, // Store red light movement check interval
            lastScene: '', // Track last played scene for game over restart
            isDying: false, // Prevent multiple death triggers while death video plays
            // Marbles Game State
            marbles: [], // Array of marble objects
            marblesLeft: 10, // Number of marbles remaining
            marbleScore: 0, // Current score
            isAiming: false, // Is player currently aiming?
            aimStartX: 0, // Mouse down position X
            aimStartY: 0, // Mouse down position Y
            currentMouseX: 0, // Current mouse position X while aiming
            currentMouseY: 0, // Current mouse position Y while aiming
            floatingTexts: [], // Floating score texts
            marblesGameWon: false, // Prevent multiple victory triggers
            // Wind System for Marbles Game
            windStrength: 0, // Wind strength (0-3)
            windAngle: 0, // Wind direction in radians
            windChangeTimer: 0, // Timer for wind changes
            windParticles: [], // Visual wind particles
            // Memory Shapes Game State
            memoryCurrentRound: 1, // Current round (1-5)
            memorySequence: [], // Sequence to memorize
            memoryPlayerSequence: [], // Player's input sequence
            memoryIsShowingSequence: false, // Currently showing sequence
            memoryIsPlayerTurn: false, // Player can click shapes
            memorySequenceIndex: 0, // Current position in sequence display
            memoryGameWon: false, // Prevent multiple victory triggers
            memoryShapes: [ // Shape definitions - centered on screen
                { type: 'circle', color: '#ff4444', activeColor: '#ffeeee', x: 350, y: 250 },
                { type: 'square', color: '#4444ff', activeColor: '#eeeeff', x: 550, y: 250 },
                { type: 'triangle', color: '#ffff44', activeColor: '#ffffff', x: 350, y: 450 },
                { type: 'star', color: '#44ff44', activeColor: '#eeffee', x: 550, y: 450 }
            ],
            memoryRounds: [ // Round configurations - starting with 4
                { round: 1, length: 4, speed: 650, description: 'Remember 4' },
                { round: 2, length: 5, speed: 600, description: 'Remember 5' },
                { round: 3, length: 6, speed: 550, description: 'Remember 6' },
                { round: 4, length: 7, speed: 500, description: 'Remember 7' },
                { round: 5, length: 8, speed: 450, description: 'Final: Remember 8' }
            ],
            // Timing and Leaderboard system
            gameStartTime: null, // When the current run started
            totalGameTime: 0, // Total time for completed run in seconds
            currentLeaderboard: [], // Current leaderboard data for display
            playerCompletionTime: 0, // Player's completion time for this run
            playerName: '', // Player's name for this run
            // Debug mode
            debugMode: false,
            debugMenuOpen: false,
            godMode: false,
            showDebugInfo: false
        };

        // Audio System
        function createBeep(frequency, duration, type = 'sine') {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.log('Audio not available');
            }
        }

        function playMenuBeep() { initAudioContext(); createBeep(800, 0.1); }
        function playDeathSound() { initAudioContext(); createBeep(150, 0.5, 'sawtooth'); }
        function playCrackSound() { initAudioContext(); createBeep(300, 0.3, 'square'); }
        function playGlassBreak() { 
            initAudioContext(); 
            createBeep(800, 0.1, 'square'); 
            setTimeout(() => createBeep(400, 0.2, 'square'), 50); 
        }
        function playVictoryFanfare() {
            initAudioContext();
            createBeep(523, 0.2);
            setTimeout(() => createBeep(659, 0.2), 200);
            setTimeout(() => createBeep(784, 0.4), 400);
        }
        
        function playScanningSound() {
            initAudioContext();
            // Quick scanning beep - descending pitch to simulate scanning sweep
            createBeep(1200, 0.1, 'sine');
            setTimeout(() => createBeep(1000, 0.1, 'sine'), 50);
            setTimeout(() => createBeep(800, 0.1, 'sine'), 100);
            setTimeout(() => createBeep(600, 0.15, 'sine'), 150);
            setTimeout(() => createBeep(400, 0.2, 'sine'), 200);
        }
        

        
        function startScanningEffect() {
            // Only start if not already scanning
            if (gameState.scanning) return;
            
            gameState.scanning = true;
            gameState.scanProgress = 0;
            
            // Animate scanning sweep over 1.2 seconds (single scan, matching shorter red light)
            const startTime = Date.now();
            const scanDuration = 1200; // 1.2 second scan
            
            function updateScan() {
                if (!gameState.scanning || currentScene !== 'redLightGreenLight') {
                    gameState.scanning = false;
                    gameState.scanProgress = 0;
                    return;
                }
                
                const elapsed = Date.now() - startTime;
                gameState.scanProgress = Math.min(elapsed / scanDuration, 1);
                
                if (gameState.scanProgress >= 1) {
                    // Scan complete - stop scanning PERMANENTLY for this red light phase
                    gameState.scanning = false;
                    gameState.scanProgress = 0;
                    // Do NOT restart the scan
                } else {
                    requestAnimationFrame(updateScan);
                }
            }
            
            requestAnimationFrame(updateScan);
        }
        
        function renderScanningEffect() {
            // Create a scanning beam effect that sweeps from right to left across the room
            const scanWidth = 80; // Width of the scanning beam
            const scanX = canvas.width - (gameState.scanProgress * (canvas.width + scanWidth));
            
            // Create gradient for the scanning beam
            const gradient = ctx.createLinearGradient(scanX, 0, scanX + scanWidth, 0);
            gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
            gradient.addColorStop(0.3, 'rgba(255, 50, 50, 0.4)');
            gradient.addColorStop(0.5, 'rgba(255, 0, 0, 0.8)');
            gradient.addColorStop(0.7, 'rgba(255, 50, 50, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
            
            // Draw the scanning beam
            ctx.save();
            ctx.fillStyle = gradient;
            ctx.fillRect(scanX, 150, scanWidth, canvas.height - 300);
            
            // Add scanning grid lines for more sci-fi effect
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.6)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const y = 150 + i * ((canvas.height - 300) / 8);
                ctx.beginPath();
                ctx.moveTo(scanX, y);
                ctx.lineTo(scanX + scanWidth, y);
                ctx.stroke();
            }
            
            // Add vertical scanning lines
            for (let i = 0; i < 3; i++) {
                const x = scanX + (i + 1) * (scanWidth / 4);
                ctx.beginPath();
                ctx.moveTo(x, 150);
                ctx.lineTo(x, canvas.height - 150);
                ctx.stroke();
            }
            
            // Add pulsing outer glow
            const glowIntensity = 0.3 + 0.2 * Math.sin(Date.now() * 0.01);
            ctx.shadowBlur = 15;
            ctx.shadowColor = `rgba(255, 0, 0, ${glowIntensity})`;
            ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(scanX - 2, 148, scanWidth + 4, canvas.height - 296);
            
            ctx.restore();
            
            // Add scanning text effect near Chloe
            ctx.save();
            ctx.font = 'bold 16px Orbitron';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff0000';
            const textFlash = Math.sin(Date.now() * 0.02) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, ${100 * textFlash}, ${100 * textFlash}, 0.9)`;
            ctx.fillText('SCANNING FOR MOVEMENT...', canvas.width - 200, 100);
            ctx.restore();
        }

        // Debug Mode Functions
        function toggleDebugMode() {
            gameState.debugMode = !gameState.debugMode;
            gameState.debugMenuOpen = gameState.debugMode;
            
            // Reset debug states when exiting
            if (!gameState.debugMode) {
                gameState.showDebugInfo = false;
                gameState.godMode = false;
            }
            
            console.log('Debug Mode:', gameState.debugMode ? 'ON' : 'OFF');
        }

        function handleDebugInput(key) {
            if (!gameState.debugMode) return;

            switch(key.toLowerCase()) {
                case 'escape':
                    gameState.debugMenuOpen = !gameState.debugMenuOpen;
                    break;
                case '1':
                    showScene('mainMenu');
                    gameState.debugMenuOpen = false;
                    console.log('Debug: Jumped to Main Menu');
                    break;
                case '2':
                    showScene('intro');
                    gameState.debugMenuOpen = false;
                    console.log('Debug: Jumped to Intro');
                    break;
                case '3':
            showScene('redLightGreenLight');
                    gameState.debugMenuOpen = false;
                    console.log('Debug: Jumped to Red Light Green Light');
                    break;
                case '4':
                    showScene('honeycomb');
                    gameState.debugMenuOpen = false;
                    console.log('Debug: Jumped to Honeycomb');
                    break;
                case '5':
                    showScene('glassBridge');
                    gameState.debugMenuOpen = false;
                    console.log('Debug: Jumped to Glass Bridge');
                    break;
                case '6':
                    showScene('marbles');
                    gameState.debugMenuOpen = false;
                    console.log('Debug: Jumped to Marbles Game');
                    break;
                case '7':
                    showScene('memoryShapes');
                    gameState.debugMenuOpen = false;
                    console.log('Debug: Jumped to Memory Shapes Game');
                    break;
                case '8':
                    showScene('finalscreen');
                    gameState.debugMenuOpen = false;
                    console.log('Debug: Jumped to Final Victory Screen');
                    break;
                case 'g':
                    gameState.godMode = !gameState.godMode;
                    console.log('God Mode:', gameState.godMode ? 'ON' : 'OFF');
                    break;
                case 'm':
                    gameState.moneyCounter = 67000000;
                    console.log('Debug: Max money set');
                    break;
                case 'w':
                    // Win current game instantly
                    if (currentScene === 'redLightGreenLight') {
                        gameState.playerPosition.x = canvas.width - 260; // Near finish line
                        console.log('Debug: Near RLGL finish line');
                    } else if (currentScene === 'honeycomb') {
                        gameState.traceProgress = 1.0;
                        gameState.honeycombComplete = true;
                        console.log('Debug: Honeycomb completed');
                    } else if (currentScene === 'glassBridge') {
                        gameState.bridgePosition = { row: 9, col: gameState.safeTiles[9] || 0 };
                        console.log('Debug: At glass bridge end');
                    } else if (currentScene === 'marbles') {
                        gameState.marbleScore = 25;
                        gameState.marblesGameWon = false; // Allow victory to trigger
                        console.log('Debug: Marbles game won (25 points)');
                    } else if (currentScene === 'memoryShapes') {
                        // Skip to final round
                        gameState.memoryCurrentRound = 5;
                        gameState.memoryGameWon = false; // Allow victory to trigger
                        // Set a simple sequence that matches the first few shapes
                        gameState.memorySequence = [0, 1, 2]; // Circle, Square, Triangle
                        gameState.memoryPlayerSequence = [0, 1]; // Almost complete
                        gameState.memoryIsPlayerTurn = true;
                        console.log('Debug: Memory shapes - almost complete, click triangle to win');
                    }
                    break;
                case 'i':
                    gameState.showDebugInfo = !gameState.showDebugInfo;
                    console.log('Debug Info Overlay:', gameState.showDebugInfo ? 'ON' : 'OFF');
                    break;
                case 'r':
                    // Reset current scene
                    showScene(currentScene);
                    console.log('Debug: Scene reset');
                    break;
                case 't':
                    // Add 30 seconds to timer
                    gameTimer += 30;
                    console.log('Debug: +30 seconds added to timer');
                    break;
                case 'h':
                    // Exit debug mode
                    toggleDebugMode();
                    break;
            }
        }

        function renderDebugMenu() {
            if (!gameState.debugMode || !gameState.debugMenuOpen) return;

            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Debug menu background
            const menuX = canvas.width / 2 - 300;
            const menuY = canvas.height / 2 - 250;
            ctx.fillStyle = 'rgba(20, 20, 20, 0.95)';
            ctx.fillRect(menuX, menuY, 600, 500);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(menuX, menuY, 600, 500);

            // Title
            ctx.font = 'bold 28px Orbitron';
            ctx.fillStyle = '#00ff00';
            ctx.textAlign = 'center';
            ctx.fillText('DEBUG MENU', canvas.width / 2, menuY + 40);

            // Menu items
            ctx.font = 'bold 16px Orbitron';
            ctx.textAlign = 'left';
            const startY = menuY + 80;
            const lineHeight = 25;

            const menuItems = [
                'SCENE NAVIGATION:',
                '1 - Main Menu',
                '2 - Intro Screen',
                '3 - Red Light Green Light',
                '4 - Honeycomb Game',
                '5 - Glass Bridge',
                '6 - Marbles Game',
                '7 - Memory Shapes Game',
                '8 - Victory Screen',
                '',
                'CHEATS:',
                'G - Toggle God Mode (Invincible): ' + (gameState.godMode ? 'ON' : 'OFF'),
                'M - Max Money ($67M)',
                'W - Win Current Game',
                'T - Add 30 Seconds to Timer',
                'R - Reset Current Scene',
                '',
                'DEBUG:',
                'I - Toggle Debug Info Overlay: ' + (gameState.showDebugInfo ? 'ON' : 'OFF'),
                'ESC - Toggle This Menu',
                'H - Exit Debug Mode',
                '',
                'Current Scene: ' + currentScene,
                'God Mode: ' + (gameState.godMode ? 'ENABLED' : 'DISABLED')
            ];

            menuItems.forEach((item, index) => {
                if (item.startsWith('SCENE') || item.startsWith('CHEATS') || item.startsWith('DEBUG')) {
                    ctx.fillStyle = '#ffff00';
                } else if (item === '') {
                    return; // Skip empty lines
                } else {
                    ctx.fillStyle = '#ffffff';
                }
                ctx.fillText(item, menuX + 20, startY + index * lineHeight);
            });
        }

        function renderDebugInfo() {
            // Always show debug mode indicator if debug is active
            if (gameState.debugMode) {
                ctx.font = 'bold 14px Orbitron';
                ctx.fillStyle = gameState.godMode ? '#ff0000' : '#00ff00';
                ctx.textAlign = 'left';
                ctx.fillText('DEBUG MODE' + (gameState.godMode ? ' + GOD MODE' : ''), 10, 30);
                ctx.fillText('Press H to exit', 10, 50);
            }
            
            if (!gameState.showDebugInfo) return;

            // Debug info overlay in top-right corner
            const startX = canvas.width - 250;
            const startY = 70; // Moved down to avoid overlap with debug mode indicator
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(startX - 10, startY - 10, 240, 200);
            
            ctx.font = 'bold 12px Orbitron';
            ctx.fillStyle = '#00ff00';
            ctx.textAlign = 'left';
            
            const debugInfo = [
                'DEBUG INFO:',
                'Scene: ' + currentScene,
                'Timer: ' + gameTimer,
                'Player X: ' + Math.floor(gameState.playerPosition.x),
                'Player Y: ' + Math.floor(gameState.playerPosition.y),
                'Is Moving: ' + gameState.isMoving,
                'Is Green Light: ' + gameState.isGreenLight,
                'Is Paused: ' + gameState.isPaused,
                'Money: $' + gameState.moneyCounter.toLocaleString(),
                'God Mode: ' + gameState.godMode,
                'Trace Progress: ' + Math.floor((gameState.traceProgress || 0) * 100) + '%'
            ];
            
            debugInfo.forEach((item, index) => {
                ctx.fillText(item, startX, startY + index * 15);
            });
        }

        // Money Falling Transition Effect
        function startMoneyFalling(nextScene) {
            gameState.isMoneyFalling = true;
            gameState.isPaused = true; // Pause the game during money falling
            gameState.nextSceneAfterMoney = nextScene; // Store next scene
            gameState.fallingMoney = [];
            
            console.log('Starting money falling, next scene:', nextScene);
            
            // Play positive money sounds
            initAudioContext();
            // Happy cash register dings
            createBeep(523, 0.3, 'sine'); // C note
            setTimeout(() => createBeep(659, 0.3, 'sine'), 150); // E note
            setTimeout(() => createBeep(784, 0.4, 'sine'), 300); // G note
            setTimeout(() => createBeep(1047, 0.5, 'sine'), 450); // High C
            
            // Excited celebration beeps
            setTimeout(() => {
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const freq = 400 + Math.random() * 400;
                        createBeep(freq, 0.1, 'triangle');
                    }, i * 100);
                }
            }, 600);
            
            // Create multiple money bills falling from top
            for (let i = 0; i < 25; i++) {
                gameState.fallingMoney.push({
                    x: Math.random() * canvas.width,
                    y: -100 - Math.random() * 200, // Start above screen
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    fallSpeed: 3 + Math.random() * 4,
                    drift: (Math.random() - 0.5) * 2
                });
            }
            
            // CRITICAL: Force transition after 3 seconds as fallback
            setTimeout(() => {
                console.log('Money falling timeout - forcing transition');
                if (gameState.isMoneyFalling && gameState.nextSceneAfterMoney) {
                    gameState.fallingMoney = [];
                    gameState.isMoneyFalling = false;
                    gameState.isPaused = false;
                    showScene(gameState.nextSceneAfterMoney);
                    gameState.nextSceneAfterMoney = '';
                }
            }, 3000);
        }

        function updateMoneyFalling() {
            if (!gameState.isMoneyFalling) return;
            
            // Update each money bill
            for (let i = gameState.fallingMoney.length - 1; i >= 0; i--) {
                const money = gameState.fallingMoney[i];
                money.y += money.fallSpeed;
                money.x += money.drift;
                money.rotation += money.rotationSpeed;
                
                // Remove money bills that fell off screen
                if (money.y > canvas.height + 100) {
                    gameState.fallingMoney.splice(i, 1);
                }
            }
            
            // Stop effect when all money has fallen and transition to next scene
            if (gameState.fallingMoney.length === 0) {
                gameState.isMoneyFalling = false;
                gameState.isPaused = false; // Unpause the game
                
                // Transition to next scene if specified
                if (gameState.nextSceneAfterMoney) {
                    showScene(gameState.nextSceneAfterMoney);
                    gameState.nextSceneAfterMoney = ''; // Clear next scene
                }
            }
        }

        function renderMoneyFalling() {
            if (!gameState.isMoneyFalling) return;
            
            gameState.fallingMoney.forEach(money => {
                ctx.save();
                ctx.translate(money.x, money.y);
                ctx.rotate(money.rotation);
                ctx.globalAlpha = 0.9;
                
                // Try to draw joe.png if it's loaded
                if (assets.joe && assets.joe.complete) {
                    // Make joe.png much bigger so it's readable - 4x bigger!
                    ctx.drawImage(assets.joe, -80, -50, 160, 100); // Much bigger joe.png
                } else {
                    // Fallback: Draw green money rectangles if asset isn't loaded
                    ctx.fillStyle = '#2a7f3e';
                    ctx.fillRect(-60, -30, 120, 60);
                    ctx.strokeStyle = '#1a5f2e';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(-60, -30, 120, 60);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 28px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$$$', 0, 0);
                }
                
                ctx.restore();
            });
        }

        // Asset Loading
        function loadAssets() {
            const assetList = [
                { name: 'startscreen', src: 'sprites/chloe/player/startscreen.png' },
                { name: 'alphacrest', src: 'sprites/chloe/player/alphacrest.png' },
                { name: 'player', src: 'sprites/chloe/player/player.png' },
                { name: 'chloeon', src: 'sprites/chloe/player/chloeon.png' }, // Chloe facing forward (can shoot)
                { name: 'chloeoff', src: 'sprites/chloe/player/chloeoff.png' }, // Chloe facing away (red light/safe)
                { name: 'rlglscreen', src: 'sprites/chloe/player/rlglscreen.png' },
                { name: 'honeycomb', src: 'sprites/chloe/player/honeycomb.png' },
                { name: 'tilesbackground', src: 'sprites/chloe/player/tilesbackground.png' },
                { name: 'tile', src: 'sprites/chloe/player/tile.png' },
                { name: 'tilelight', src: 'sprites/chloe/player/tilelight.png' },
                                  { name: 'money', src: 'sprites/chloe/player/money.png' },
                  { name: 'victory', src: 'sprites/chloe/player/victory.png' }, // Victory background
                  { name: 'introback', src: 'sprites/chloe/player/introback.png' }, // Intro background
                  { name: 'joe', src: 'sprites/chloe/player/joe.png' }, // Money bills for transition
                  { name: 'sadboy', src: 'sprites/chloe/player/sadboy.png' }, // Sad image for debt counting
                  // Marbles Game Assets
                  { name: 'marbscreen', src: 'sprites/chloe/player/marbscreen.png' }, // Marbles background
                  { name: 'marble', src: 'sprites/chloe/player/marble.png' }, // Marble image
                  // Memory Shapes Game Assets
                  { name: 'memoryback', src: 'sprites/chloe/player/memoryback.png' }, // Memory game background
                  // Shell Game Cookie Challenge Assets
                  { name: 'box', src: 'sprites/chloe/player/box.png' },
                { name: 'evan', src: 'sprites/chloe/player/Evan.png' },
                { name: 'backpack', src: 'sprites/chloe/player/backpack.png' },
                { name: 'brain', src: 'sprites/chloe/player/brain.png' },
                { name: 'circle', src: 'sprites/chloe/player/circle.png' }
            ];

            let loadedCount = 0;
            
            assetList.forEach(asset => {
                const img = new Image();
                img.crossOrigin = 'anonymous'; // Add CORS support
                img.onload = () => {
                    console.log(`âœ… Loaded asset: ${asset.name} from ${asset.src}`);
                    loadedCount++;
                    if (loadedCount === assetList.length) {
                        console.log('All assets loaded, starting game');
                        initGame();
                    }
                };
                img.onerror = (e) => {
                    console.warn(`âŒ Failed to load ${asset.name} from ${asset.src}`, e);
                    loadedCount++;
                    if (loadedCount === assetList.length) {
                        console.log('Some assets failed, starting game anyway');
                        initGame();
                    }
                };
                // For local development, use relative paths. For Vercel, use absolute paths
                const path = window.location.hostname === 'localhost' 
                    ? asset.src 
                    : (asset.src.startsWith('/') ? asset.src : '/' + asset.src);
                console.log(`Loading ${asset.name} from: ${path}`);
                img.src = path;
                assets[asset.name] = img;
            });
        }

        // Scene Management
        function showScene(sceneName) {
            console.log('Switching to scene:', sceneName, 'from:', currentScene);
            currentScene = sceneName;
            gameState.keys = {};
            
            // Reset dying flag when changing scenes
            gameState.isDying = false;
            
            // Track last scene for game over restart (only for game scenes)
            if (['redLightGreenLight', 'honeycomb', 'glassBridge', 'marbles', 'memoryShapes'].includes(sceneName)) {
                gameState.lastScene = sceneName;
            }
            
            // Stop current music before switching scenes
            stopBackgroundMusic();
            
            // Clear UI
            document.getElementById('timerDisplay').textContent = '';
            document.getElementById('gameStatus').textContent = '';
            document.getElementById('instructions').textContent = '';
            
            // CRITICAL: Clear ALL intervals to prevent stuck scenes
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
            if (gameState.lightInterval) {
                clearInterval(gameState.lightInterval);
                gameState.lightInterval = null;
            }
            if (gameState.redLightCheckInterval) {
                clearInterval(gameState.redLightCheckInterval);
                gameState.redLightCheckInterval = null;
            }
            
            // Clear Red Light Green Light specific state
            gameState.isGreenLight = false;
            gameState.isMoving = false;
            gameState.isWarningFlash = false;
            gameState.isDarkFlash = false;
            gameState.lightFlicker = 0; // Reset glass bridge flickering
            gameState.isPaused = false; // Ensure game is not paused
            gameState.nextSceneAfterMoney = ''; // Clear next scene tracking
            gameState.obstacles = []; // Clear obstacles
            gameState.obstaclesInitialized = false;
            gameState.scanning = false; // Clear scanning state
            gameState.scanProgress = 0;
            
            // Scene-specific setup
            switch(sceneName) {
                case 'mainMenu':
                    setupMainMenu();
                    break;
                case 'intro':
                    setupIntro();
                    break;
                case 'redLightGreenLight':
                    setupRedLightGreenLight();
                    break;
                case 'honeycomb':
                    setupHoneycomb();
                    break;
                case 'glassBridge':
                    setupGlassBridge();
                    break;
                case 'marbles':
                    setupMarbles();
                    break;
                case 'memoryShapes':
                    setupMemoryShapes();
                    break;
                case 'gameOver':
                    setupGameOver();
                    break;
                case 'win':
                    setupWin();
                    break;
                case 'finalscreen':
                    setupFinalScreen();
                    break;
            }
        }

        // Scene Setup Functions
        function setupMainMenu() {
            gameState.moneyCounter = 0;
            gameState.flickerTime = 0;
            gameState.horrorAudioPlayed = false;
            
            // Reset timing for new game
            gameState.gameStartTime = null;
            gameState.totalGameTime = 0;
            gameState.currentLeaderboard = [];
            gameState.playerCompletionTime = 0;
            gameState.playerName = '';
            
            // Play subtle horror ambience
            if (!gameState.horrorAudioPlayed) {
                // Play eerie background atmosphere
                const mainTimeout = setTimeout(() => {
                    if (currentScene === 'mainMenu') { // Only play if still on main menu
                        initAudioContext();
                        // Deep atmospheric rumble
                        createBeep(30, 4.0, 'sawtooth');
                        // Subtle high-pitched tension
                        const timeout1 = setTimeout(() => {
                            if (currentScene === 'mainMenu') createBeep(800, 0.5, 'sine');
                        }, 2000);
                        gameState.horrorAudioTimeouts.push(timeout1);
                        
                        // Creepy mid-range whisper
                        const timeout2 = setTimeout(() => {
                            if (currentScene === 'mainMenu') createBeep(150, 2.0, 'triangle');
                        }, 3000);
                        gameState.horrorAudioTimeouts.push(timeout2);
                        
                        // Distant electrical hum
                        const timeout3 = setTimeout(() => {
                            if (currentScene === 'mainMenu') createBeep(120, 3.0, 'square');
                        }, 4500);
                        gameState.horrorAudioTimeouts.push(timeout3);
                    }
                }, 1000);
                gameState.horrorAudioTimeouts.push(mainTimeout);
                gameState.horrorAudioPlayed = true;
            }
            
            // Start main theme music immediately on main menu
            playSceneMusic('main');
        }

        function setupIntro() {
            // Clear any pending main menu music timeout
            if (gameState.mainMenuMusicTimeout) {
                clearTimeout(gameState.mainMenuMusicTimeout);
                gameState.mainMenuMusicTimeout = null;
            }
            
            // Clear all horror audio timeouts to prevent sounds during intro
            gameState.horrorAudioTimeouts.forEach(timeout => clearTimeout(timeout));
            gameState.horrorAudioTimeouts = [];
            
            gameState.moneyCounter = 0;
            gameState.introStage = 0;
            gameState.currentTextLine = 0;
            gameState.introLines = [
                "Your AlphaX project was not good enough for Chloe.",
                "You've spent four years doing absolute shit. You aren't an expert,",
                "you have only 10 followers on TikTok, and you are NOT graduating dawg.",
                "",
                "Unless you survive THE ALPHA GAMES! Then, you will graduate.",
                "But if you loseâ€¦ you will DIE!",
                "",
                "You are student #67.",
                "",
                "Press any key to begin"
            ];
            gameState.visibleLines = [];
            
            // Play intro music during intro scene
            playSceneMusic('intro');
            
            setTimeout(() => {
                const countInterval = setInterval(() => {
                    gameState.moneyCounter += 1000000;
                    
                    // Money counting sound effects removed per user request
                    
                    if (gameState.moneyCounter >= 67000000) {
                        gameState.moneyCounter = 67000000;
                        clearInterval(countInterval);
                        gameState.introStage = 1;
                        
                        // Final money counter sound removed per user request
                        
                        // Start showing text lines one by one
                        startTextSequence();
                    }
                }, 50);
            }, 1000);
        }

        function startTextSequence() {
            const showNextLine = () => {
                if (gameState.currentTextLine < gameState.introLines.length) {
                    gameState.visibleLines.push(gameState.introLines[gameState.currentTextLine]);
                    gameState.currentTextLine++;
                    // Show next line after delay (faster for empty lines, slower for text)
                    const delay = gameState.introLines[gameState.currentTextLine - 1] === "" ? 500 : 2000;
                    gameState.nextLineTimeout = setTimeout(showNextLine, delay);
                } else {
                    gameState.introStage = 2; // Ready for interaction
                }
            };
            showNextLine();
        }

        function advanceIntroText() {
            // Skip to next line immediately if user clicks
            if (gameState.currentTextLine < gameState.introLines.length) {
                if (gameState.nextLineTimeout) {
                    clearTimeout(gameState.nextLineTimeout);
                }
                gameState.visibleLines.push(gameState.introLines[gameState.currentTextLine]);
                gameState.currentTextLine++;
                
                if (gameState.currentTextLine < gameState.introLines.length) {
                    // Continue with next line immediately
                    const delay = gameState.introLines[gameState.currentTextLine - 1] === "" ? 100 : 300;
                    gameState.nextLineTimeout = setTimeout(() => {
                        advanceIntroText();
                    }, delay);
                } else {
                    gameState.introStage = 2; // Ready for interaction
                }
            }
        }

        function setupRedLightGreenLight() {
            // CRITICAL: Clear any existing movement check interval
            if (gameState.redLightCheckInterval) {
                clearInterval(gameState.redLightCheckInterval);
                gameState.redLightCheckInterval = null;
            }
            
            // FORCE TIMER TO 40 - BALANCED DIFFICULTY
            gameTimer = 40;
            console.log('SETUP: gameTimer forced to 40 seconds:', gameTimer);
            
            // IMMEDIATELY SET DISPLAY TO 40
            document.getElementById('timerDisplay').textContent = '40';
            console.log('SETUP: timerDisplay set to 40');
            
            // Start the overall game timer for leaderboard tracking
            startLeaderboardTimer();
            
            // Start at left side of classroom
            gameState.playerPosition = { x: 80, y: canvas.height / 2, scale: 1.0 };
            gameState.isGreenLight = true;
            gameState.isMoving = false;
            gameState.movementKeys = new Set(); // Reset movement keys tracking
            gameState.isWarningFlash = false;
            gameState.scanning = false;
            gameState.scanProgress = 0;
            
            // Initialize obstacles for added challenge
            initObstacles();
            
            // Generate other players spread across the starting area (left side)
            gameState.otherPlayers = [];
            for (let i = 0; i < 12; i++) {
                gameState.otherPlayers.push({
                    x: 50 + Math.random() * 100, // Start clustered at left
                    y: 200 + Math.random() * 400, // Spread vertically
                    scale: 1.0, // All stay at full size - no scaling
                    number: Math.floor(Math.random() * 99) + 1,
                    baseSpeed: 0.8 + Math.random() * 1.2, // Base movement speed
                    eliminated: false
                });
            }
            
            startRedLightGreenLightTimer(); // Start the countdown timer
            startLightCycle();
            
            // Play background music for Red Light Green Light scene
            playSceneMusic('redLightGreenLight');
            
            document.getElementById('instructions').textContent = 'Cross the classroom! AVOID BOXES! Move with ARROW KEYS/WASD. When you see RED WARNING, STOP IMMEDIATELY! Chloe scans once then turns back. 40 seconds!';
        }

        function setupHoneycomb() {
            // NUCLEAR cleanup of ALL previous game state
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
            if (gameState.lightInterval) {
                clearInterval(gameState.lightInterval);
                gameState.lightInterval = null;
            }
            
            // Stop any current music immediately and wait
            stopBackgroundMusic();
            
            // COMPLETE reset of ALL Red Light Green Light state
            gameState.isGreenLight = false;
            gameState.isMoving = false;
            gameState.isWarningFlash = false;
            gameState.playerPosition = null;
            gameState.otherPlayers = [];
            
            // Reset darkness effect
            gameState.isDarkFlash = false;
            
            // Clear ALL UI elements to prevent bleed
            document.getElementById('timerDisplay').textContent = '';
            document.getElementById('gameStatus').textContent = '';
            
            // Initialize Shell Game Cookie Challenge state - FORCE 30 SECONDS
            gameTimer = 30;
            document.getElementById('timerDisplay').textContent = '30';
            console.log('HONEYCOMB SETUP: Timer forced to 30');
            gameState.shellGamePhase = 1; // Phase 1: Introduction
            gameState.phaseStartTime = Date.now();
            gameState.honeycombComplete = false;
            // Removed darkness effect - moved to Glass Bridge
            
            // Shell Game Box System - 4 boxes in a 2x2 grid
            gameState.boxes = [
                {id: 0, cookie: 'evan', originalX: -75, originalY: -75, x: -75, y: -75, rotation: 0},
                {id: 1, cookie: 'backpack', originalX: 75, originalY: -75, x: 75, y: -75, rotation: 0},
                {id: 2, cookie: 'brain', originalX: -75, originalY: 75, x: -75, y: 75, rotation: 0},
                {id: 3, cookie: 'circle', originalX: 75, originalY: 75, x: 75, y: 75, rotation: 0}
            ];
            
            console.log('Honeycomb boxes initialized:', gameState.boxes.length, 'boxes');
            
            gameState.selectedBox = null;
            gameState.selectedCookie = null;
            gameState.showingCookies = true; // Phase 1: show cookies on boxes
            gameState.shuffling = false;
            gameState.shuffleRotation = 0;
            gameState.shuffleSpeed = 0;
            gameState.swapCount = 0;
            gameState.mousePos = null; // Initialize mouse position tracking
            
            // Simple mouse tracing - no needle cursor needed
            
            // Tracing system
            gameState.tracingActive = false;
            gameState.tracingStarted = false;
            gameState.isMouseDown = false; // Track mouse down/up for hold-to-trace
            gameState.tracePath = [];
            gameState.traceProgress = 0;
            
            // Use normal cursor for tracing
            canvas.style.cursor = 'crosshair';
            
            // Start Chris music for Shell Game scene
            setTimeout(() => {
                if (currentScene === 'honeycomb') {
                    console.log('ðŸŽµ Starting Chris music for Shell Game scene...');
                    playSceneMusic('honeycomb');
                }
            }, 500);
            
            // Initialize PNG outline extraction for all cookie types
            initializeCookieOutlines();
            
            // Start phase progression
            startShellGamePhases();
            
            document.getElementById('instructions').textContent = 'Remember your cookie...';
        }

        // PNG Outline Extraction System
        function initializeCookieOutlines() {
            // Extract outlines from all cookie PNG images
            gameState.cookieOutlines = {};
            
            const cookieTypes = ['evan', 'backpack', 'brain', 'circle'];
            cookieTypes.forEach(cookieType => {
                const cookieAsset = assets[cookieType];
                if (cookieAsset && cookieAsset.complete) {
                    console.log(`ðŸª Extracting outline for ${cookieType}...`);
                    try {
                        gameState.cookieOutlines[cookieType] = extractOutlineFromPNG(cookieAsset);
                        console.log(`ðŸª Found ${gameState.cookieOutlines[cookieType].edgePixels.length} edge pixels for ${cookieType}`);
                    } catch (err) {
                        console.log(`âš ï¸ Error extracting outline for ${cookieType}:`, err);
                        // Create fallback outline data
                        gameState.cookieOutlines[cookieType] = {
                            edgePixels: [],
                            width: 300,
                            height: 300
                        };
                    }
                } else {
                    console.log(`âš ï¸ Could not load ${cookieType} asset - creating fallback`);
                    // Create fallback outline data
                    gameState.cookieOutlines[cookieType] = {
                        edgePixels: [],
                        width: 300,
                        height: 300
                    };
                }
            });
        }

        function extractOutlineFromPNG(cookieImage) {
            // Create temporary canvas to extract image data
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = cookieImage.width;
            tempCanvas.height = cookieImage.height;
            
            // Draw cookie image
            tempCtx.drawImage(cookieImage, 0, 0);
            
            // Get image data to detect edges
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Extract edge pixels for outline detection
            const outlineData = {
                width: imageData.width,
                height: imageData.height,
                data: imageData.data,
                edgePixels: findEdgePixels(imageData)
            };
            
            return outlineData;
        }

        function findEdgePixels(imageData) {
            const { width, height, data } = imageData;
            const rawEdgePixels = [];
            
            // First pass: Find all edge pixels where transparent meets non-transparent
            for (let y = 2; y < height - 2; y++) { // Leave more margin to avoid artifacts
                for (let x = 2; x < width - 2; x++) {
                    const centerAlpha = getAlphaAt(data, x, y, width);
                    
                                // If pixel is visible (non-transparent) and has sufficient opacity
            if (centerAlpha > 32) { // Even lower threshold to catch more edge pixels, especially for backpack
                // Check if it has any transparent neighbors (making it an edge)
                if (hasTransparentNeighbor(data, x, y, width, height)) {
                    rawEdgePixels.push({ x, y });
                }
            }
                }
            }
            
            // Second pass: Clean up jagged artifacts by removing isolated pixels
            const cleanedPixels = [];
            for (let pixel of rawEdgePixels) {
                // Count nearby edge pixels within a small radius
                let nearbyCount = 0;
                for (let other of rawEdgePixels) {
                    if (other === pixel) continue;
                    const dist = Math.sqrt((other.x - pixel.x)**2 + (other.y - pixel.y)**2);
                    if (dist <= 3) { // Within 3 pixels
                        nearbyCount++;
                    }
                }
                
                // Only keep pixels that have at least 1 nearby edge pixel (less aggressive cleaning for backpack)
                if (nearbyCount >= 1) {
                    cleanedPixels.push(pixel);
                }
            }
            
            // Third pass: Keep ALL pixels for complete outline coverage (especially for backpack)
            const finalPixels = [...cleanedPixels]; // Keep every pixel for complete coverage
            
            console.log(`Found ${rawEdgePixels.length} raw edge pixels â†’ ${cleanedPixels.length} cleaned â†’ ${finalPixels.length} final pixels`);
            return finalPixels;
        }

        function hasTransparentNeighbor(data, x, y, width, height) {
            // Check expanded 5x5 surrounding pixels for better edge detection
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    if (dx === 0 && dy === 0) continue; // Skip center
                    
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    // Check bounds
                    if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
                        continue; // Treat out-of-bounds as transparent
                    }
                    
                    const neighborAlpha = getAlphaAt(data, nx, ny, width);
                    if (neighborAlpha === 0) { // Completely transparent neighbor
                        return true;
                    }
                }
            }
            return false;
        }

        function getAlphaAt(data, x, y, width) {
            const index = (y * width + x) * 4 + 3; // Alpha channel
            return data[index] || 0;
        }

        function isOnPNGOutline(x, y, cookieType, centerX, centerY, size, tolerance = 10) {
            const outlineData = gameState.cookieOutlines[cookieType];
            if (!outlineData || !outlineData.edgePixels) {
                console.log(`âš ï¸ No outline data for ${cookieType}`);
                return false;
            }
            
            // Scale coordinates from game canvas to image coordinates
            const scaleX = outlineData.width / size;
            const scaleY = outlineData.height / size;
            
            // Transform game coordinates to image coordinates (centered)
            const gameOffsetX = x - centerX; // Offset from center in game
            const gameOffsetY = y - centerY;
            
            // Convert to image coordinates (image center = width/2, height/2)
            const imageX = Math.round(gameOffsetX * scaleX + outlineData.width / 2);
            const imageY = Math.round(gameOffsetY * scaleY + outlineData.height / 2);
            
            // Check bounds
            if (imageX < 0 || imageX >= outlineData.width || 
                imageY < 0 || imageY >= outlineData.height) {
                return false;
            }
            
            // Check if point is near any edge pixel within tolerance
            for (const edgePixel of outlineData.edgePixels) {
                const distance = Math.sqrt(
                    Math.pow(imageX - edgePixel.x, 2) + 
                    Math.pow(imageY - edgePixel.y, 2)
                );
                
                if (distance <= tolerance) {
                    return true;
                }
            }
            
            return false;
        }

        // Shell Game Phase Management
        function startShellGamePhases() {
            // Phase 1: Introduction (2 seconds) - already started
            setTimeout(() => {
                if (currentScene === 'honeycomb' && gameState.shellGamePhase === 1) {
                    startPhase2(); // Shapes enter boxes
                }
            }, 2000);
        }

        function startPhase2() {
            gameState.shellGamePhase = 2;
            gameState.phaseStartTime = Date.now();
            gameState.showingCookies = false; // Hide cookies (slide into boxes)
            document.getElementById('instructions').textContent = 'The shapes enter their boxes...';
            
            // Play whoosh sound
            playWhooshSound();
            
            // After 1 second, start shuffle phase
            setTimeout(() => {
                if (currentScene === 'honeycomb' && gameState.shellGamePhase === 2) {
                    startPhase3(); // Shuffle
                }
            }, 1000);
        }

        function startPhase3() {
            gameState.shellGamePhase = 3;
            gameState.phaseStartTime = Date.now();
            gameState.shuffling = true;
            gameState.shuffleSpeed = 0.02; // Start slow
            gameState.shuffleRotation = 0; // Reset rotation
            gameState.swapCount = 0; // Reset swap count
            console.log('Starting shuffle phase - boxes should spin now');
            document.getElementById('instructions').textContent = 'The boxes are shuffling...';
            
            // Play shuffle sounds
            playShuffleSound();
            
            // After 3 seconds, stop shuffle and start selection
            setTimeout(() => {
                if (currentScene === 'honeycomb' && gameState.shellGamePhase === 3) {
                    console.log('Shuffle complete, moving to selection phase');
                    startPhase4(); // Selection
                }
            }, 3000);
        }

        function startPhase4() {
            gameState.shellGamePhase = 4;
            gameState.phaseStartTime = Date.now();
            gameState.shuffling = false;
            gameState.shuffleRotation = 0;
            gameState.shuffleSpeed = 0;
            document.getElementById('instructions').textContent = 'Choose your cookie. You get one chance.';
        }

        function startPhase5(chosenCookie) {
            gameState.shellGamePhase = 5;
            gameState.phaseStartTime = Date.now();
            gameState.selectedCookie = chosenCookie;
            gameState.tracingActive = true;
            
            // Start the 30-second timer - FORCE DISPLAY
            gameTimer = 30;
            document.getElementById('timerDisplay').textContent = '30';
            console.log('HONEYCOMB PHASE 5: Timer forced to 30');
            startGameTimer();
            
            const cookieNames = {
                'evan': 'EVAN\'S HEAD',
                'backpack': 'BACKPACK', 
                'brain': 'BRAIN',
                'circle': 'CIRCLE'
            };
            
            document.getElementById('instructions').textContent = `Trace the ${cookieNames[chosenCookie]} outline with your mouse!`;
        }

        // Sound effects for shell game
        function playWhooshSound() {
            initAudioContext();
            // Declining beep for whoosh
            createBeep(440, 0.3);
            setTimeout(() => createBeep(330, 0.3), 150);
            setTimeout(() => createBeep(220, 0.4), 300);
        }

        function playShuffleSound() {
            initAudioContext();
            // Rapid beeps for shuffling
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    createBeep(440 + Math.random() * 200, 0.1);
                }, i * 200);
            }
        }

        // Box shuffling algorithm
        function updateShuffle() {
            if (!gameState.shuffling) return;
            
            const elapsed = Date.now() - gameState.phaseStartTime;
            const progress = elapsed / 3000; // 3 second shuffle
            
            // Speed curve: slow -> fast -> slow
            if (progress < 0.3) {
                gameState.shuffleSpeed = 0.02 + progress * 0.1; // Accelerate
            } else if (progress > 0.7) {
                gameState.shuffleSpeed = Math.max(0.02, 0.12 - (progress - 0.7) * 0.3); // Decelerate
            } else {
                gameState.shuffleSpeed = 0.12; // Fast spin
            }
            
            // Update rotation
            gameState.shuffleRotation += gameState.shuffleSpeed;
            
            // Log rotation every 500ms for debugging
            if (elapsed % 500 < 16) {
                console.log('Shuffle rotation:', gameState.shuffleRotation.toFixed(2), 'Speed:', gameState.shuffleSpeed.toFixed(3));
            }
            
            // Random position swaps during shuffle
            if (elapsed % 300 < 16 && gameState.swapCount < 10) { // Swap every ~300ms
                swapRandomBoxes();
                gameState.swapCount++;
            }
        }

        function swapRandomBoxes() {
            if (!gameState.boxes || gameState.boxes.length < 4) {
                console.error('Cannot swap boxes - boxes not properly initialized');
                return;
            }
            
            const box1 = Math.floor(Math.random() * 4);
            let box2 = Math.floor(Math.random() * 4);
            while (box2 === box1) {
                box2 = Math.floor(Math.random() * 4);
            }
            
            // Swap positions
            const tempX = gameState.boxes[box1].x;
            const tempY = gameState.boxes[box1].y;
            gameState.boxes[box1].x = gameState.boxes[box2].x;
            gameState.boxes[box1].y = gameState.boxes[box2].y;
            gameState.boxes[box2].x = tempX;
            gameState.boxes[box2].y = tempY;
        }

        function setupGlassBridge() {
            // FORCE TIMER TO 30 - GLASS BRIDGE
            gameTimer = 30;
            document.getElementById('timerDisplay').textContent = '30';
            console.log('GLASS BRIDGE SETUP: Timer forced to 30');
            
            // Clean up any previous game state
            gameState.honeycombComplete = false;
            gameState.tracingActive = false;
            gameState.tracingStarted = false;
            
            gameState.bridgePosition = { row: -1, col: 0 }; // Start above tiles, -1 means at starting position
            gameState.onBridge = false;
            gameState.selectedTile = null; // Track which tile is selected
            
            // Initialize light flickering
            gameState.lightFlicker = 0;
            
            // Add lights out effect to Glass Bridge
            gameState.isDarkFlash = false;
            gameState.lastDarkFlash = Date.now();
            
            // Generate safe tiles - 10 rows, 2 columns each, one safe per row
            gameState.safeTiles = [];
            for (let i = 0; i < 10; i++) {
                gameState.safeTiles[i] = Math.random() < 0.5 ? 0 : 1; // 0 = left safe, 1 = right safe
            }
            
            startGameTimer();
            
            // Play final song for glass bridge scene
            playSceneMusic('glassBridge');
            
            document.getElementById('instructions').innerHTML = 'ðŸ–±ï¸ CLICK tile to select &nbsp;â€¢&nbsp; SPACE to jump &nbsp;â€¢&nbsp; Move upward row by row!';
        }

        function setupGameOver() {
            // Set different restart instructions based on current scene
            let restartText = 'Press any key to restart current game';
            if (gameState.lastScene === 'redLightGreenLight') {
                restartText = 'Press any key to restart Red Light Green Light';
            } else if (gameState.lastScene === 'honeycomb') {
                restartText = 'Press any key to restart Honeycomb Game';
            } else if (gameState.lastScene === 'glassBridge') {
                restartText = 'Press any key to restart Glass Bridge';
            }
            
            document.getElementById('instructions').textContent = restartText;
            
            // Stop all music on game over
            stopBackgroundMusic();
            
            // Play death audio sequence
            setTimeout(() => {
                initAudioContext();
                createBeep(100, 1.0, 'sawtooth'); // Death sound
                setTimeout(() => createBeep(50, 2.0, 'triangle'), 500); // Fade out
            }, 200);
        }

        function setupWin() {
            document.getElementById('instructions').textContent = 'Press any key to return to menu';
        }

        function setupFinalScreen() {
            // Calculate final completion time
            const completionTime = calculateGameTime();
            
            // Stop scene music for finale
            stopBackgroundMusic();
            
            // Play celebratory sounds
            playCelebrationSounds();
            
            // Prompt for player name and add to leaderboard
            setTimeout(() => {
                const playerName = prompt(`ðŸ† CONGRATULATIONS! You completed Alpha Games in ${formatTime(completionTime)}!\n\nEnter your name for the leaderboard:`) || 'Anonymous';
                const leaderboard = addToLeaderboard(playerName, completionTime);
                gameState.currentLeaderboard = leaderboard;
                gameState.playerCompletionTime = completionTime;
                gameState.playerName = playerName;
                
                console.log('ðŸ† Added to leaderboard:', playerName, formatTime(completionTime));
            }, 1000);
            
            document.getElementById('instructions').innerHTML = 'Congratulations! You completed all the Alpha Games!<br/>ðŸ† LEADERBOARD DISPLAYED BELOW ðŸ†<br/>Press SPACE to download leaderboard JSON â€¢ Press any other key to return to menu';
        }

        function playCelebrationSounds() {
            // Play a sequence of triumphant beeps
            setTimeout(() => {
                initAudioContext();
                createBeep(523, 0.3); // C5
            }, 200);
            setTimeout(() => createBeep(659, 0.3), 400); // E5
            setTimeout(() => createBeep(784, 0.3), 600); // G5
            setTimeout(() => createBeep(1047, 0.5), 800); // C6
            setTimeout(() => createBeep(1047, 0.8), 1200); // C6 longer
            
            // Add some sparkly high notes
            setTimeout(() => createBeep(1568, 0.2), 1600); // G6
            setTimeout(() => createBeep(1397, 0.2), 1800); // F6
            setTimeout(() => createBeep(1047, 0.4), 2000); // C6
        }

        // Honeycomb circle tracing - no longer need Alpha A functions

        // Red Light Green Light Game Timer (countdown timer)
        function startRedLightGreenLightTimer() {
            // Clear any existing timer first
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            // Force timer to 40 seconds for Red Light Green Light (balanced difficulty)
            gameTimer = 40;
            console.log(`ðŸ• Starting Red Light Green Light timer: ${gameTimer} seconds`);
            document.getElementById('timerDisplay').textContent = gameTimer;
            
            gameState.timerInterval = setInterval(() => {
                gameTimer--;
                document.getElementById('timerDisplay').textContent = gameTimer;
                console.log(`â±ï¸ Timer: ${gameTimer} seconds remaining`);
                
                if (gameTimer <= 0) {
                    console.log('â° Time is up!');
                    gameOver("Time's up!");
                }
            }, 1000);
        }
        
        // Marbles Game Timer (45 seconds)
        function startMarblesTimer() {
            // Clear any existing timer first
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            // Keep timer at 45 seconds for marbles
            console.log(`ðŸŽ¯ Starting marbles timer: ${gameTimer} seconds`);
            document.getElementById('timerDisplay').textContent = gameTimer;
            
            gameState.timerInterval = setInterval(() => {
                gameTimer--;
                document.getElementById('timerDisplay').textContent = gameTimer;
                
                if (gameTimer <= 0) {
                    // Don't call gameOver here - let checkMarblesWinLoss handle it
                    clearInterval(gameState.timerInterval);
                }
            }, 1000);
        }
        
        // General Game Timer for other scenes
        function startGameTimer() {
            // Clear any existing timer first
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            // Force timer to 30 seconds for all games
            gameTimer = 30;
            console.log(`ðŸ• Starting game timer: ${gameTimer} seconds`);
            document.getElementById('timerDisplay').textContent = gameTimer;
            
            gameState.timerInterval = setInterval(() => {
                gameTimer--;
                document.getElementById('timerDisplay').textContent = gameTimer;
                
                if (gameTimer <= 0) {
                    gameOver("Time's up!");
                }
            }, 1000);
        }

        function startLightCycle() {
            // Start with green light phase
            // First green light gives players a good amount of time to start moving
            const firstGreenDuration = 5000 + Math.random() * 2000; // 5-7 seconds for first green light
            
            setTimeout(() => {
                if (currentScene === 'redLightGreenLight') {
                    startWarningFlash();
                }
            }, firstGreenDuration);
        }

        function scheduleNextLightChange() {
            if (gameState.isGreenLight) {
                // During green light - schedule warning flash before turning red
                // MUCH longer green lights to make the game beatable!
                const greenDuration = 6000 + Math.random() * 3000; // 6-9 seconds of green (plenty of time to move)
                
                setTimeout(() => {
                    if (currentScene === 'redLightGreenLight') {
                        startWarningFlash();
                    }
                }, greenDuration);
                
                } else {
                // During red light - schedule turning back to green
                // Shorter red light so players aren't stuck waiting too long
                const redDuration = 1500 + Math.random() * 500; // 1.5-2 seconds of red (one quick scan then green)
                
                setTimeout(() => {
                    if (currentScene === 'redLightGreenLight') {
                        turnGreen();
                    }
                }, redDuration);
            }
        }

        function startWarningFlash() {
            // Clear any existing movement check (safety measure)
            if (gameState.redLightCheckInterval) {
                clearInterval(gameState.redLightCheckInterval);
                gameState.redLightCheckInterval = null;
            }
            
            // Start warning flash (Chloe's backside flashes red)
            gameState.isWarningFlash = true;
            gameState.isMoving = false; // Reset movement flag during warning
            // No warning text or sound - just the visual flash
            
            // After 500 milliseconds (0.5 seconds), turn red - gives players proper warning
            setTimeout(() => {
                if (currentScene === 'redLightGreenLight') {
                    turnRed();
                }
            }, 500);
        }

        function turnRed() {
            gameState.isGreenLight = false;
            gameState.isWarningFlash = false;
            
            // Reset movement state when red light starts
            // This gives players a clean slate - they must actively move during red to be caught
            gameState.isMoving = false;
            
            // Clear the movement keys set to prevent false positives
            gameState.movementKeys.clear();
            
            // Clear all movement keys when red light starts
            // This prevents false positives from keys held during green light
            const movementKeys = ['d', 'arrowright', 'a', 'arrowleft', 'w', 'arrowup', 's', 'arrowdown'];
            movementKeys.forEach(key => {
                gameState.keys[key] = false;
            });
            
            // Start scanning effect when Chloe turns around
            playScanningSound();
            startScanningEffect();
            
            document.getElementById('gameStatus').textContent = 'RECEIVE FEEDBACK - RED - STOP!';
            document.getElementById('gameStatus').style.color = '#ff0000';
            
            // Wait for grace period then check for movement ONLY during red light
            setTimeout(() => {
                // Only start checking if we're still in red light
                if (currentScene === 'redLightGreenLight' && !gameState.isGreenLight) {
                    // Reset movement flag and keys after grace period - give players a clean slate
                    gameState.isMoving = false;
                    gameState.movementKeys.clear();
                    
                    // Start monitoring for NEW movement during red light
                    gameState.redLightCheckInterval = setInterval(() => {
                        // CRITICAL: Only check if still red light (not green!)
                        if (currentScene === 'redLightGreenLight' && !gameState.isGreenLight) {
                            // Only kill if player is ACTIVELY pressing movement keys during red light
                            // Must have keys currently pressed, not just the flag
                            if (gameState.movementKeys.size > 0) {
                                clearInterval(gameState.redLightCheckInterval);
                                gameState.redLightCheckInterval = null;
                                gameOver('Caught moving! Chloe saw you move during red light.');
                            }
                        } else {
                            // Stop checking immediately when light turns green
                            clearInterval(gameState.redLightCheckInterval);
                            gameState.redLightCheckInterval = null;
                        }
                    }, 100); // Check every 100ms
                }
            }, 700); // 0.7 second grace period to stop moving (fair amount of time)
            
            // Schedule next change (back to green)
            scheduleNextLightChange();
        }

        function turnGreen() {
            gameState.isGreenLight = true;
            gameState.isWarningFlash = false;
            
            // CRITICAL: Reset movement flag and keys when turning green
            gameState.isMoving = false;
            gameState.movementKeys.clear(); // Clear any stuck movement keys
            
            // Stop scanning effect when turning green
            gameState.scanning = false;
            gameState.scanProgress = 0;
            
            // Clear any red light movement checking IMMEDIATELY
            if (gameState.redLightCheckInterval) {
                clearInterval(gameState.redLightCheckInterval);
                gameState.redLightCheckInterval = null;
            }
            
            document.getElementById('gameStatus').textContent = 'GIVE FEEDBACK - GREEN - MOVE!';
            document.getElementById('gameStatus').style.color = '#00ff00';
            
            // Schedule next change (to warning flash)
            scheduleNextLightChange();
        }
        
        // Obstacle System Functions
        function initObstacles() {
            gameState.obstacles = [
                // Row 1 - closer to start
                { x: 250, y: 250, width: 50, height: 50, speed: 0, type: 'box' },
                { x: 250, y: 450, width: 50, height: 50, speed: 0, type: 'box' },
                
                // Row 2 - middle area
                { x: 400, y: 350, width: 50, height: 50, speed: 0, type: 'box' },
                { x: 400, y: 550, width: 50, height: 50, speed: 0, type: 'box' },
                
                // Row 3 - zigzag pattern
                { x: 550, y: 200, width: 50, height: 50, speed: 0, type: 'box' },
                { x: 550, y: 400, width: 50, height: 50, speed: 0, type: 'box' },
                { x: 550, y: 600, width: 50, height: 50, speed: 0, type: 'box' },
                
                // Row 4 - near finish
                { x: 700, y: 300, width: 50, height: 50, speed: 0, type: 'box' },
                { x: 700, y: 500, width: 50, height: 50, speed: 0, type: 'box' },
                
                // Row 5 - more obstacles on right side
                { x: 850, y: 250, width: 50, height: 50, speed: 0, type: 'box' },
                { x: 850, y: 400, width: 50, height: 50, speed: 0, type: 'box' },
                { x: 850, y: 550, width: 50, height: 50, speed: 0, type: 'box' },
                
                // Row 6 - even more on the right
                { x: 950, y: 300, width: 50, height: 50, speed: 0, type: 'box' },
                { x: 950, y: 450, width: 50, height: 50, speed: 0, type: 'box' },
                
                // Final row before finish line
                { x: 1050, y: 350, width: 50, height: 50, speed: 0, type: 'box' },
                { x: 1050, y: 500, width: 50, height: 50, speed: 0, type: 'box' }
            ];
            gameState.obstaclesInitialized = true;
        }
        
        function updateObstacles() {
            // Obstacles are now static - no movement needed
            // This function is kept for compatibility but does nothing
            if (!gameState.obstaclesInitialized) return;
        }
        
        function renderObstacles() {
            if (!gameState.obstaclesInitialized) return;
            
            gameState.obstacles.forEach(obstacle => {
                ctx.save();
                
                if (obstacle.type === 'box') {
                    // Draw wooden box
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Add crate lines
                    ctx.strokeStyle = '#654321';
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x, obstacle.y + obstacle.height/2);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height/2);
                    ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height);
                    ctx.stroke();
                } else {
                    // Draw floating paper
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Add paper lines
                    ctx.strokeStyle = '#666';
                    for (let i = 1; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + 5, obstacle.y + (obstacle.height/4) * i);
                        ctx.lineTo(obstacle.x + obstacle.width - 5, obstacle.y + (obstacle.height/4) * i);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            });
        }
        

        
        function checkObstacleCollision() {
            if (!gameState.obstaclesInitialized) return;
            
            // Player position is the center, so adjust for collision detection
            const playerWidth = 60;
            const playerHeight = 80;
            const playerX = gameState.playerPosition.x - playerWidth/2;
            const playerY = gameState.playerPosition.y - playerHeight/2;
            
            gameState.obstacles.forEach(obstacle => {
                if (playerX < obstacle.x + obstacle.width &&
                    playerX + playerWidth > obstacle.x &&
                    playerY < obstacle.y + obstacle.height &&
                    playerY + playerHeight > obstacle.y) {
                    
                    // HIT AN OBSTACLE! Kill player
                    flashScreen('red');
                    playDeathSound();
                    gameOver('Crashed into a box! Navigate around them carefully!');
                }
            });
        }
        

        
        function increaseDifficulty() {
            // No longer needed for static obstacles
            // Function kept for compatibility
        }
        
        function flashScreen(color) {
            ctx.save();
            ctx.fillStyle = color === 'blue' ? 'rgba(0, 100, 255, 0.5)' : 'rgba(255, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
        
        function checkNPCObstacleCollision(npcX, npcY, npcWidth, npcHeight) {
            if (!gameState.obstaclesInitialized) return false;
            
            for (let obstacle of gameState.obstacles) {
                if (npcX < obstacle.x + obstacle.width &&
                    npcX + npcWidth > obstacle.x &&
                    npcY < obstacle.y + obstacle.height &&
                    npcY + npcHeight > obstacle.y) {
                    return true; // Collision detected
                }
            }
            return false;
        }
        
        function moveNPCWithObstacleAvoidance(player, finishLineX) {
            if (!gameState.isGreenLight || player.x >= finishLineX - 50) return;
            
            const npcWidth = 50;
            const npcHeight = 70;
            
            // Try moving forward first
            const newX = player.x + player.baseSpeed;
            if (!checkNPCObstacleCollision(newX, player.y, npcWidth, npcHeight)) {
                player.x = newX;
                return;
            }
            
            // If blocked, try moving up or down to avoid static obstacle
            const avoidanceDistance = 25; // Larger avoidance distance for static boxes
            
            // Try moving up
            const newYUp = Math.max(player.y - avoidanceDistance, 200);
            if (!checkNPCObstacleCollision(newX, newYUp, npcWidth, npcHeight)) {
                player.x = newX;
                player.y = newYUp;
                return;
            }
            
            // Try moving down
            const newYDown = Math.min(player.y + avoidanceDistance, canvas.height - 220);
            if (!checkNPCObstacleCollision(newX, newYDown, npcWidth, npcHeight)) {
                player.x = newX;
                player.y = newYDown;
                return;
            }
            
            // If still blocked, just wait (don't move) - rare with static obstacles
        }

        // Death Video Functions
        function showDeathVideo() {
            const videoContainer = document.getElementById('deathVideoContainer');
            const video = document.getElementById('deathVideo');
            
            // Show the video container
            videoContainer.style.display = 'block';
            
            // Reset video to beginning and play
            video.currentTime = 0;
            video.muted = false; // Unmute for death video
            
            // Play the video
            const playPromise = video.play();
            
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log('Death video started playing');
                }).catch(error => {
                    console.error('Error playing death video:', error);
                    // If video fails to play, proceed to game over immediately
                    hideDeathVideoAndShowGameOver();
                });
            }
            
            // Listen for video end
            video.onended = function() {
                hideDeathVideoAndShowGameOver();
            };
            
            // Prevent skipping video with mouse/touch
            video.onclick = function(e) {
                e.preventDefault();
                return false;
            };
            
            // Prevent right-click context menu
            video.oncontextmenu = function(e) {
                e.preventDefault();
                return false;
            };
        }
        
        function hideDeathVideoAndShowGameOver() {
            const videoContainer = document.getElementById('deathVideoContainer');
            const video = document.getElementById('deathVideo');
            
            // Hide the video container
            videoContainer.style.display = 'none';
            
            // Pause and reset video
            video.pause();
            video.currentTime = 0;
            video.muted = true; // Mute again for future use
            
            // Remove event listeners
            video.onended = null;
            video.onclick = null;
            video.oncontextmenu = null;
            
            // Reset dying flag to allow new deaths after respawn
            gameState.isDying = false;
            
            // Show the game over scene
            showScene('gameOver');
        }

        // Death and Win Functions
        function gameOver(reason) {
            // God mode protection - don't die if god mode is enabled
            if (gameState.godMode) {
                console.log('Debug: God mode prevented death -', reason);
                return;
            }
            
            // Prevent multiple death triggers while already dying
            if (gameState.isDying) {
                console.log('Debug: Already dying, ignoring repeated death trigger -', reason);
                return;
            }
            
            // Set dying flag to prevent repeated triggers
            gameState.isDying = true;
            
            // Clear all intervals
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            if (gameState.lightInterval) clearInterval(gameState.lightInterval);
            if (gameState.redLightCheckInterval) {
                clearInterval(gameState.redLightCheckInterval);
                gameState.redLightCheckInterval = null;
            }
            
            // Always go directly to game over screen - no death video
            playDeathSound();
            gameState.isDying = false; // Reset dying flag
            showScene('gameOver');
        }

        function winGame() {
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            if (gameState.lightInterval) clearInterval(gameState.lightInterval);
            
            // Go directly to final diploma screen
            showScene('finalscreen');
        }

        // Rendering Functions
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            switch(currentScene) {
                case 'mainMenu':
                    renderMainMenu();
                    break;
                case 'intro':
                    renderIntro();
                    break;
                case 'redLightGreenLight':
                    renderRedLightGreenLight();
                    break;
                case 'honeycomb':
                    renderHoneycomb();
                    break;
                case 'glassBridge':
                    renderGlassBridge();
                    break;
                case 'marbles':
                    renderMarbles();
                    break;
                case 'memoryShapes':
                    renderMemoryShapes();
                    break;
                case 'gameOver':
                    renderGameOver();
                    break;
                case 'win':
                    renderWin();
                    break;
                case 'finalscreen':
                    renderFinalScreen();
                    break;
            }
            
            // Update and render money falling effect
            updateMoneyFalling();
            renderMoneyFalling();
            
            // Debug rendering (always last so it's on top)
            renderDebugInfo();
            renderDebugMenu();
            
            requestAnimationFrame(render);
        }

        function renderMainMenu() {
            // Clean startscreen - just the PNG image
            if (assets.startscreen && assets.startscreen.complete) {
                ctx.drawImage(assets.startscreen, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback dark background if image doesn't load
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function renderIntro() {
            // Use introback.png as background
            if (assets.introback && assets.introback.complete) {
                ctx.drawImage(assets.introback, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback black background if image doesn't load
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Debt from Tuition counter (the one and only counter)
            ctx.font = 'bold 48px Orbitron';
            ctx.fillStyle = '#ff0000';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff0000';
            ctx.fillText(`Debt from Tuition: $${gameState.moneyCounter.toLocaleString()}`, canvas.width / 2, 200);
            ctx.shadowBlur = 0;
            
            // Show sadboy.png while debt is counting up
            if (gameState.moneyCounter < 67000000 && assets.sadboy && assets.sadboy.complete) {
                // Center the sadboy image below the debt counter - MUCH BIGGER
                const sadWidth = 400;
                const sadHeight = 400;
                ctx.drawImage(assets.sadboy, 
                    (canvas.width - sadWidth) / 2, 
                    250, 
                    sadWidth, 
                    sadHeight
                );
            }
            
            // Show lines one by one
            if (gameState.introStage >= 1 && gameState.visibleLines) {
                ctx.font = 'bold 26px Orbitron';
                ctx.fillStyle = '#fff';
                
                gameState.visibleLines.forEach((line, i) => {
                    if (line === "") return; // Skip empty lines for rendering
                    
                    // Add fade-in effect for the most recent line
                    if (i === gameState.visibleLines.length - 1 && gameState.introStage < 2) {
                        ctx.fillStyle = '#ffff00'; // Highlight current line
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ffff00';
                    } else {
                        ctx.fillStyle = '#fff';
                        ctx.shadowBlur = 0;
                    }
                    
                    // Special styling for key lines
                    if (line.includes("THE ALPHA GAMES")) {
                        ctx.fillStyle = '#ff0000';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff0000';
                        ctx.font = 'bold 30px Orbitron';
                    } else if (line.includes("student #67")) {
                        ctx.fillStyle = '#ffd700';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ffd700';
                        ctx.font = 'bold 32px Orbitron';
                    } else if (line.includes("Press any key")) {
                        ctx.fillStyle = gameState.introStage === 2 ? '#00ff00' : '#666';
                        ctx.shadowBlur = gameState.introStage === 2 ? 15 : 0;
                        ctx.shadowColor = '#00ff00';
                        ctx.font = 'bold 24px Orbitron';
                    } else {
                        ctx.font = 'bold 26px Orbitron';
                    }
                    
                    ctx.fillText(line, canvas.width / 2, 280 + i * 40);
                    ctx.shadowBlur = 0;
                });
                
                // Show click hint if text is still appearing
                if (gameState.introStage === 1 && gameState.currentTextLine < gameState.introLines.length) {
                    const hintFlash = Math.sin(Date.now() / 600) * 0.3 + 0.7;
                    ctx.font = 'bold 18px Orbitron';
                    ctx.fillStyle = `rgba(255, 255, 0, ${hintFlash})`;
                    ctx.fillText('Click anywhere to speed through text...', canvas.width / 2, canvas.height - 40);
                }
            }
        }

        function renderRedLightGreenLight() {
            // Background - classroom perspective
            if (assets.rlglscreen && assets.rlglscreen.complete) {
                ctx.drawImage(assets.rlglscreen, 0, 0, canvas.width, canvas.height);
            } else {
                // Draw classroom background
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw floor tiles perspective
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                for (let i = 0; i < 20; i++) {
                    const x = 60 + i * 55;
                    ctx.beginPath();
                    ctx.moveTo(x, 150);
                    ctx.lineTo(x, canvas.height - 150);
                    ctx.stroke();
                }
                
                // Horizontal lines for depth
                for (let i = 0; i < 8; i++) {
                    const y = 150 + i * 75;
                    ctx.beginPath();
                    ctx.moveTo(60, y);
                    ctx.lineTo(canvas.width - 60, y);
                    ctx.stroke();
                }
            }
            
            // Starting line (vertical line on left)
            const startLineX = 100;
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 6;
            ctx.setLineDash([15, 15]);
            ctx.beginPath();
            ctx.moveTo(startLineX, 150);
            ctx.lineTo(startLineX, canvas.height - 150);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.font = 'bold 24px Orbitron';
            ctx.fillStyle = '#00ff00';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(startLineX - 30, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('START', 0, 0);
            ctx.restore();
            
            // Finish line (vertical line on right side, middle of screen)
            const finishLineX = canvas.width - 200; // Not at edge, but well to the right
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 8;
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.moveTo(finishLineX, 150);
            ctx.lineTo(finishLineX, canvas.height - 150);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.font = 'bold 32px Orbitron';
            ctx.fillStyle = '#ff0000';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff0000';
            ctx.save();
            ctx.translate(finishLineX + 40, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('FINISH', 0, 0);
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // LARGE Chloe teacher positioned behind finish line at right side
            const chloe = gameState.isGreenLight ? assets.chloeoff : assets.chloeon;
            if (chloe && chloe.complete) {
                const chloeSize = 180; // Much larger
                const chloeX = finishLineX + 50; // Behind finish line
                const chloeY = canvas.height / 2 - chloeSize; // Center vertically
                
                // Draw Chloe normally
                ctx.drawImage(chloe, chloeX, chloeY, chloeSize, chloeSize * 1.8);
                
                // RED FLASH WARNING: Flash Chloe's backside red before turning around
                if (gameState.isWarningFlash && gameState.isGreenLight) {
                    // Stronger pulsing red flash effect on the backside
                    const flashAlpha = 0.5 + 0.4 * Math.sin(Date.now() * 0.03); // Stronger, faster pulsing
                    ctx.save();
                    ctx.globalAlpha = flashAlpha;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(chloeX, chloeY, chloeSize, chloeSize * 1.8);
                    ctx.restore();
                    
                    // Stronger warning glow around Chloe
                    ctx.save();
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#ff0000';
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 8;
                    ctx.strokeRect(chloeX - 10, chloeY - 10, chloeSize + 20, chloeSize * 1.8 + 20);
                    ctx.restore();
                    
                    // Add warning text
                    ctx.save();
                    ctx.font = 'bold 36px Orbitron';
                    ctx.fillStyle = '#ff0000';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff0000';
                    ctx.fillText('âš  ABOUT TO TURN âš ', canvas.width / 2, 100);
                    ctx.restore();
                }
                
                // No red dots/eyes during red light - removed for cleaner look
            }
            
            // No scaling - everyone stays the same size
            function calculateScale(x) {
                return 1.0; // Always return full size - no scaling
            }
            
            // Update and render obstacles
            updateObstacles();
            renderObstacles();
            
            // Other players with perspective scaling
            if (gameState.otherPlayers) {
                gameState.otherPlayers.forEach(player => {
                    if (!player.eliminated) {
                        // Move other players during green light with obstacle avoidance
                        if (gameState.isGreenLight) {
                            moveNPCWithObstacleAvoidance(player, finishLineX);
                        } else {
                            // Some players move during red light and get eliminated
                            if (Math.random() < 0.001 && player.x > 300) {
                                player.eliminated = true;
                                // Flash effect for eliminated player
                                ctx.fillStyle = '#ff0000';
                                ctx.shadowBlur = 20;
                                ctx.shadowColor = '#ff0000';
                                const size = 60; // Fixed size - no scaling
                                ctx.fillRect(player.x - 5, player.y - 5, size + 10, size + 15);
                                ctx.shadowBlur = 0;
                                return;
                            }
                        }
                        
                        // Draw other player with fixed size - no scaling
                        const playerSize = 50; // Fixed size
                        const playerHeight = 70; // Fixed size
                        
                        if (assets.player && assets.player.complete) {
                            ctx.save();
                            ctx.filter = 'brightness(0.6) saturate(0.7) hue-rotate(' + (player.number * 3) + 'deg)';
                            ctx.drawImage(assets.player, player.x - playerSize/2, player.y - playerHeight/2, playerSize, playerHeight);
                            ctx.restore();
                        } else {
                            ctx.fillStyle = '#666';
                            ctx.fillRect(player.x - playerSize/2, player.y - playerHeight/2, playerSize, playerHeight);
                        }
                        
                        // Player number - fixed size
                        const fontSize = 16; // Fixed font size - no scaling
                        ctx.font = `bold ${fontSize}px Orbitron`;
                        ctx.fillStyle = '#fff';
                        ctx.textAlign = 'center';
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.strokeText(player.number, player.x, player.y - playerHeight/2 - 10);
                        ctx.fillText(player.number, player.x, player.y - playerHeight/2 - 10);
                    }
                });
            }
            
            // Main player with no scaling - stays same size
            gameState.playerPosition.scale = 1.0; // Always full size
            const playerSize = 60; // Fixed size - no scaling
            const playerHeight = 80; // Fixed size - no scaling
            
            if (assets.player && assets.player.complete) {
                ctx.drawImage(assets.player, 
                    gameState.playerPosition.x - playerSize/2, 
                    gameState.playerPosition.y - playerHeight/2, 
                    playerSize, playerHeight);
            } else {
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(gameState.playerPosition.x - playerSize/2, 
                    gameState.playerPosition.y - playerHeight/2, 
                    playerSize, playerHeight);
            }
            
            // Player number - fixed size
            const fontSize = 24; // Fixed font size - no scaling
            ctx.font = `bold ${fontSize}px Orbitron`;
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeText('67', gameState.playerPosition.x, gameState.playerPosition.y - playerHeight/2 - 15);
            ctx.fillText('67', gameState.playerPosition.x, gameState.playerPosition.y - playerHeight/2 - 15);
            
            // Progress indicator - horizontal progress to Chloe
            const totalDistance = finishLineX - 80;
            const currentDistance = gameState.playerPosition.x - 80;
            const progress = Math.max(0, Math.min(100, (currentDistance / totalDistance) * 100));
            
            // Progress bar
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(20, 20, 300, 25);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 20, 300, 25);
            
            ctx.fillStyle = progress >= 100 ? '#00ff00' : '#ffff00';
            ctx.fillRect(22, 22, (progress / 100) * 296, 21);
            
            ctx.font = 'bold 16px Orbitron';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'left';
            ctx.fillText(`Distance to Chloe: ${Math.floor(progress)}%`, 20, 15);
            
            // Obstacles removed from game
            
            // Scanning effect when Chloe is scanning for movement
            if (gameState.scanning) {
                renderScanningEffect();
            }
            
            // No scale indicator needed - everyone stays same size
        }

        function renderHoneycomb() {
            // Use introback.png as background
            if (assets.introback && assets.introback.complete) {
                ctx.drawImage(assets.introback, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback dark classroom background
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Update shuffle animation if needed
            if (gameState.shuffling) {
                updateShuffle();
            }
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Darkness effect moved to Glass Bridge game
            
            // Phase-specific rendering
            switch(gameState.shellGamePhase) {
                case 1: // Introduction - show cookies on boxes
                    renderPhase1(centerX, centerY);
                    break;
                case 2: // Shapes slide into boxes
                    renderPhase2(centerX, centerY);
                    break;
                case 3: // Shuffling
                    renderPhase3(centerX, centerY);
                    break;
                case 4: // Selection
                    renderPhase4(centerX, centerY);
                    break;
                case 5: // Tracing (darkness effect moved to Glass Bridge)
                    renderPhase5(centerX, centerY);
                    break;
            }
            
            // Darkness effect moved to Glass Bridge game
            
            // No needle cursor needed - using normal mouse
        }

        function renderPhase1(centerX, centerY) {
            ctx.font = 'bold 36px Orbitron';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('SHELL GAME CHALLENGE', centerX, 80);
            
            // Check if boxes exist
            if (!gameState.boxes || gameState.boxes.length === 0) {
                console.error('No boxes to render in Phase 1!');
                ctx.fillStyle = '#ff0000';
                ctx.fillText('ERROR: Boxes not initialized!', centerX, 200);
                return;
            }
            
            // Debug box asset loading
            if (!assets.box) {
                console.log('Box asset not in assets object');
            } else if (!assets.box.complete) {
                console.log('Box asset not complete/loaded');
            } else {
                console.log('Box asset ready to use');
            }
            
            // Render 4 boxes in 2x2 formation
            gameState.boxes.forEach((box, index) => {
                const boxX = centerX + box.x - 50;
                const boxY = centerY + box.y - 50;
                
                // Draw box - use box.png if available, fallback to rectangle
                if (assets.box && assets.box.complete) {
                    ctx.drawImage(assets.box, boxX, boxY, 100, 100);
                } else {
                    // Fallback to brown rectangle if asset not loaded
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(boxX, boxY, 100, 100);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(boxX, boxY, 100, 100);
                    
                    // Draw box number for debugging only in fallback
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText((index + 1).toString(), boxX + 50, boxY + 55);
                }
                
                // Draw cookie on top of box if showing
                if (gameState.showingCookies) {
                    const cookieAsset = assets[box.cookie];
                    if (cookieAsset && cookieAsset.complete) {
                        ctx.drawImage(cookieAsset, boxX + 10, boxY - 60, 80, 80);
                    } else {
                        // Draw placeholder for cookie
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(boxX + 50, boxY - 20, 30, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(box.cookie.toUpperCase(), boxX + 50, boxY - 15);
                    }
                }
            });
        }

        function renderPhase2(centerX, centerY) {
            ctx.font = 'bold 36px Orbitron';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('SHAPES ENTERING BOXES', centerX, 80);
            
            if (!gameState.boxes || gameState.boxes.length === 0) {
                console.error('No boxes to render in Phase 2!');
                return;
            }
            
            // Render boxes (cookies sliding in - simplified animation)
            gameState.boxes.forEach(box => {
                const boxX = centerX + box.x - 50;
                const boxY = centerY + box.y - 50;
                
                // Draw box - use box.png if available
                if (assets.box && assets.box.complete) {
                    ctx.drawImage(assets.box, boxX, boxY, 100, 100);
                } else {
                    // Fallback with texture lines
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(boxX, boxY, 100, 100);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(boxX, boxY, 100, 100);
                    
                    // Add box texture lines for fallback
                    ctx.strokeStyle = '#7a5c3a';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(boxX, boxY + 33);
                    ctx.lineTo(boxX + 100, boxY + 33);
                    ctx.moveTo(boxX, boxY + 66);
                    ctx.lineTo(boxX + 100, boxY + 66);
                    ctx.moveTo(boxX + 33, boxY);
                    ctx.lineTo(boxX + 33, boxY + 100);
                    ctx.moveTo(boxX + 66, boxY);
                    ctx.lineTo(boxX + 66, boxY + 100);
                    ctx.stroke();
                }
            });
        }

        function renderPhase3(centerX, centerY) {
            ctx.font = 'bold 36px Orbitron';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('SHUFFLING...', centerX, 80);
            
            if (!gameState.boxes || gameState.boxes.length === 0) {
                console.error('No boxes to render in Phase 3!');
                return;
            }
            
            ctx.save();
            // Rotate entire box formation
            ctx.translate(centerX, centerY);
            ctx.rotate(gameState.shuffleRotation);
            
            // Add blur effect during fast spinning
            if (gameState.shuffleSpeed > 0.08) {
                ctx.filter = 'blur(2px)';
            }
            
            // Render boxes in their current positions
            gameState.boxes.forEach(box => {
                const boxX = box.x - 50;
                const boxY = box.y - 50;
                
                // Draw box - use box.png if available
                if (assets.box && assets.box.complete) {
                    ctx.drawImage(assets.box, boxX, boxY, 100, 100);
                } else {
                    // Fallback to rectangle
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(boxX, boxY, 100, 100);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(boxX, boxY, 100, 100);
                }
            });
            
            ctx.restore();
        }

        function renderPhase4(centerX, centerY) {
            ctx.font = 'bold 36px Orbitron';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('CHOOSE YOUR FATE', centerX, 80);
            
            if (!gameState.boxes || gameState.boxes.length === 0) {
                console.error('No boxes to render in Phase 4!');
                return;
            }
            
            // Render boxes with hover effects
            gameState.boxes.forEach((box, index) => {
                const boxX = centerX + box.x - 50;
                const boxY = centerY + box.y - 50;
                
                // Check if hovering
                const isHovering = gameState.mousePos && 
                    gameState.mousePos.x >= boxX && gameState.mousePos.x <= boxX + 100 &&
                    gameState.mousePos.y >= boxY && gameState.mousePos.y <= boxY + 100;
                
                // Hover glow effect
                if (isHovering) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ff00';
                } else {
                    ctx.shadowBlur = 0;
                }
                
                // Draw box
                if (assets.box && assets.box.complete) {
                    ctx.drawImage(assets.box, boxX, boxY, 100, 100);
                } else {
                    ctx.fillStyle = isHovering ? '#A0522D' : '#8B4513';
                    ctx.fillRect(boxX, boxY, 100, 100);
                }
            });
            
            ctx.shadowBlur = 0;
            
            // Show selection prompt
            ctx.font = 'bold 20px Orbitron';
            ctx.fillStyle = '#ffaa00';
            ctx.fillText('Click to reveal your cookie!', centerX, centerY + 200);
        }

        function renderPhase5(centerX, centerY) {
            ctx.font = 'bold 36px Orbitron';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            
            const cookieNames = {
                'evan': 'EVAN\'S HEAD',
                'backpack': 'BACKPACK', 
                'brain': 'BRAIN',
                'circle': 'CIRCLE'
            };
            
            ctx.fillText(`TRACE THE ${cookieNames[gameState.selectedCookie]}`, centerX, 80);
            
            // Add instructions
            ctx.font = 'bold 18px Orbitron';
            ctx.fillStyle = '#ffaa00';
            ctx.fillText('DRAG ALL AROUND THE OUTLINE - 90% COVERAGE REQUIRED!', centerX, 120);
            
            // Render the selected cookie large in center with cookie square background
            const cookieAsset = assets[gameState.selectedCookie];
            if (cookieAsset && cookieAsset.complete) {
                const size = 300;
                
                // Draw cookie square background (like a biscuit to carve from)
                ctx.fillStyle = '#D2B48C'; // Light brown cookie color
                ctx.fillRect(centerX - size/2 - 20, centerY - size/2 - 20, size + 40, size + 40);
                
                // Add cookie texture border
                ctx.strokeStyle = '#8B7355'; // Darker brown border
                ctx.lineWidth = 4;
                ctx.strokeRect(centerX - size/2 - 20, centerY - size/2 - 20, size + 40, size + 40);
                
                // Add consistent cookie texture dots (no random flicker)
                ctx.fillStyle = '#8B7355';
                for (let i = 0; i < 12; i++) {
                    const x = centerX - size/2 + (i % 4) * (size/3) + 15; // Fixed positions
                    const y = centerY - size/2 + Math.floor(i/4) * (size/3) + 15;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2); // Smaller, more subtle dots
                    ctx.fill();
                }
                
                // Draw the cookie shape on top (this is what you're carving out)
                ctx.drawImage(cookieAsset, centerX - size/2, centerY - size/2, size, size);
                
                // Draw outline path for tracing
                drawCookieOutline(gameState.selectedCookie, centerX, centerY, size);
                
                // Show traced path - THICKER and MORE VISIBLE
                if (gameState.tracePath.length > 1) {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 6; // Thicker traced path for better visibility
                    ctx.shadowBlur = 12; // Bigger glow for the traced path
                    ctx.shadowColor = '#ffd700';
                    ctx.lineCap = 'round'; // Smooth line endings
                    ctx.lineJoin = 'round'; // Smooth line joins
                    ctx.beginPath();
                    ctx.moveTo(gameState.tracePath[0].x, gameState.tracePath[0].y);
                    for (let i = 1; i < gameState.tracePath.length; i++) {
                        ctx.lineTo(gameState.tracePath[i].x, gameState.tracePath[i].y);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Show progress
            const progress = Math.floor(gameState.traceProgress * 100);
            ctx.font = 'bold 24px Orbitron';
            ctx.fillStyle = progress >= 95 ? '#00ff00' : '#fff';
            ctx.fillText(`${progress}% Complete - NEED 95%! DRAG ACROSS ENTIRE OUTLINE!`, centerX, centerY + 200);
            
            // Show timer warning if low
            if (gameTimer <= 10) {
                ctx.font = 'bold 28px Orbitron';
                ctx.fillStyle = '#ff0000';
                ctx.fillText(`âš ï¸ TIME: ${gameTimer} âš ï¸`, centerX, 120);
            }
        }

        // Needle cursor removed - using normal mouse cursor

        function drawCookieOutline(cookieType, centerX, centerY, size) {
            const outlineData = gameState.cookieOutlines[cookieType];
            if (!outlineData || !outlineData.edgePixels) {
                console.log(`âš ï¸ No outline data for ${cookieType}`);
                return;
            }
            
            // Draw glowing outline following the actual cookie shape - EXTRA THICK for easier tracing!
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 10; // Extra thick line for easier tracing, especially backpack
            ctx.shadowBlur = 15; // Bigger glow effect
            ctx.shadowColor = '#00ff88';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Scale factors to convert image coordinates to game coordinates
            const scaleX = size / outlineData.width;
            const scaleY = size / outlineData.height;
            
            // Draw the outline by connecting edge pixels
            ctx.beginPath();
            let firstPoint = true;
            
            // Sort edge pixels to create a connected path (simple approach)
            const sortedEdges = [...outlineData.edgePixels].sort((a, b) => {
                // Sort by angle from center for a rough outline
                const centerImgX = outlineData.width / 2;
                const centerImgY = outlineData.height / 2;
                const angleA = Math.atan2(a.y - centerImgY, a.x - centerImgX);
                const angleB = Math.atan2(b.y - centerImgY, b.x - centerImgX);
                return angleA - angleB;
            });
            
            // Draw points as a connected path
            for (const edge of sortedEdges) {
                // Convert image coordinates to game coordinates
                const gameX = centerX + (edge.x - outlineData.width / 2) * scaleX;
                const gameY = centerY + (edge.y - outlineData.height / 2) * scaleY;
                
                if (firstPoint) {
                    ctx.moveTo(gameX, gameY);
                    firstPoint = false;
                } else {
                    ctx.lineTo(gameX, gameY);
                }
            }
            
            ctx.closePath();
            ctx.stroke();
            
            // Reset shadow
            ctx.shadowBlur = 0;
            
            // Add instruction text
            ctx.font = 'bold 14px Orbitron';
            ctx.fillStyle = '#00ff88';
            ctx.textAlign = 'center';
            ctx.fillText('Trace the glowing outline with your mouse!', centerX, centerY + size/2 + 30);
        }

        function renderGlassBridge() {
            // Background - use tilesbackground.png
            if (assets.tilesbackground && assets.tilesbackground.complete) {
                ctx.drawImage(assets.tilesbackground, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // 10 rows x 2 columns of tiles - bigger and fill the whole screen!
            const tileWidth = 120;
            const tileHeight = 60;
            const totalTileWidth = tileWidth * 2; // Two tiles side by side
            const startX = (canvas.width - totalTileWidth) / 2; // Perfect center
            const startY = 100; // Start position
            const availableHeight = canvas.height - startY - 50; // Leave 50px at bottom
            const rowSpacing = availableHeight / 10; // Distribute evenly to fill screen
            
            // Check if safe tiles should flash (every 5 seconds)
            const time = Date.now() / 5000; // 5-second cycle
            const flashPhase = time % 1; // Get the decimal part (0-1)
            const shouldFlash = flashPhase > 0.92 && flashPhase < 0.96; // Much more subtle flash (harder to notice!)
            
            // Render 10 rows x 2 columns of tiles going upward - all visible!
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 2; col++) {
                    const x = startX + col * tileWidth;
                    const y = startY + row * rowSpacing;
                    
                    // Check if this tile is safe
                    const isSafe = gameState.safeTiles[row] === col;
                    
                    // Use tilelight.png for safe tiles when flashing, tile.png otherwise
                    const tileImage = (isSafe && shouldFlash) ? assets.tilelight : assets.tile;
                    
                    // Add elevation shadow first
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(x + 8, y + 8, tileWidth, tileHeight);
                    
                    if (tileImage && tileImage.complete) {
                        ctx.drawImage(tileImage, x, y, tileWidth, tileHeight);
                    } else {
                        // Fallback tile rendering with elevation
                        ctx.fillStyle = (isSafe && shouldFlash) ? '#88ccff' : '#4a90e2';
                        ctx.fillRect(x, y, tileWidth, tileHeight);
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, tileWidth, tileHeight);
                    }
                    
                    // Add glass shine effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(x, y, tileWidth, tileHeight / 3);
                    
                    // Tile selection highlight
                    if (gameState.selectedTile && gameState.selectedTile.row === row && gameState.selectedTile.col === col) {
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
                        ctx.fillRect(x, y, tileWidth, tileHeight);
                        
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(x + 2, y + 2, tileWidth - 4, tileHeight - 4);
                    }
                }
            }
            
            // Player position
            if (gameState.bridgePosition.row >= 0) {
                // Player is on a tile
                const playerX = startX + gameState.bridgePosition.col * tileWidth + tileWidth/2;
                const playerY = startY + gameState.bridgePosition.row * rowSpacing + tileHeight/2;
                
                if (assets.player && assets.player.complete) {
                    ctx.drawImage(assets.player, playerX - 30, playerY - 40, 60, 80);
                } else {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(playerX, playerY, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.font = 'bold 16px Orbitron';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeText('67', playerX, playerY - 50);
                ctx.fillText('67', playerX, playerY - 50);
            } else {
                // Player at starting position (top of screen, ready to jump onto first tile)
                const playerStartX = canvas.width / 2;
                const playerStartY = 30; // Position well above first tiles (tiles start at y=100)
                
                if (assets.player && assets.player.complete) {
                    ctx.drawImage(assets.player, playerStartX - 30, playerStartY, 60, 80);
                } else {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(playerStartX - 15, playerStartY + 20, 30, 40);
                }
                
                ctx.font = 'bold 20px Orbitron';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeText('67', playerStartX, playerStartY - 10);
                ctx.fillText('67', playerStartX, playerStartY - 10);
            }
            
            // Title
            ctx.font = 'bold 28px Orbitron';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0066cc';
            ctx.fillText('GLASS BRIDGE', canvas.width / 2, 50);
            ctx.shadowBlur = 0;
            
            // Single instruction area - no overlapping
            ctx.font = 'bold 18px Orbitron';
            if (gameState.bridgePosition.row >= 0) {
                // On bridge - show progress
                ctx.fillStyle = '#00ff00';
                ctx.fillText(`Row ${gameState.bridgePosition.row + 1} of 10`, canvas.width / 2, 80);
                
                if (gameState.selectedTile) {
                    const tileText = gameState.selectedTile.col === 0 ? 'LEFT' : 'RIGHT';
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(`${tileText} tile selected - SPACE to jump!`, canvas.width / 2, 100);
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.fillText('Click a tile in the next row', canvas.width / 2, 100);
                }
            } else {
                // Starting position
                if (gameState.selectedTile) {
                    const tileText = gameState.selectedTile.col === 0 ? 'LEFT' : 'RIGHT';
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(`${tileText} tile selected - SPACE to start!`, canvas.width / 2, 80);
                } else {
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillText('Click a tile in the first row to begin!', canvas.width / 2, 80);
                }
            }
            
            // Update light flickering
            gameState.lightFlicker += 0.1;
            
            // Flickering light effects
            if (Math.sin(gameState.lightFlicker * 0.8) > 0.7) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Random flickers
            if (Math.random() < 0.05) { // 5% chance per frame
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Glass catching light text - appears periodically
            if (Math.sin(gameState.lightFlicker * 0.3) > 0.8) {
                ctx.font = 'italic 16px Orbitron';
                ctx.fillStyle = 'rgba(200, 200, 255, 0.8)';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ffffff';
                ctx.fillText('Tempered glass sometimes catches the light...', canvas.width / 2, canvas.height - 30);
                ctx.shadowBlur = 0;
            }
            
            // Check for lights out effect every 6 seconds during Glass Bridge
            const timeSinceLastFlash = Date.now() - gameState.lastDarkFlash;
            if (timeSinceLastFlash >= 6000) { // 6 seconds
                gameState.isDarkFlash = true;
                gameState.lastDarkFlash = Date.now();
                
                // Darkness lasts for 1.5 seconds
                setTimeout(() => {
                    gameState.isDarkFlash = false;
                }, 1500);
            }
            
            // Apply lights out overlay if active
            if (gameState.isDarkFlash) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Show warning text during lights out
                ctx.font = 'bold 36px Orbitron';
                ctx.fillStyle = '#ff4444';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#ff0000';
                ctx.fillText('LIGHTS OUT!', canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
                
                // Additional warning text
                ctx.font = 'bold 18px Orbitron';
                ctx.fillStyle = '#ffaa00';
                ctx.fillText('Be careful where you step...', canvas.width / 2, canvas.height / 2 + 50);
            }
        }

        function setupMarbles() {
            // FORCE TIMER TO 30 SECONDS for marbles
            gameTimer = 30;
            document.getElementById('timerDisplay').textContent = '30';
            console.log('MARBLES SETUP: Timer forced to 30 seconds');
            
            // Reset marbles game state
            gameState.marbles = [];
            gameState.marblesLeft = 10;
            gameState.marbleScore = 0;
            gameState.isAiming = false;
            gameState.aimStartX = 0;
            gameState.aimStartY = 0;
            gameState.currentMouseX = 0;
            gameState.currentMouseY = 0;
            gameState.floatingTexts = [];
            gameState.marblesGameWon = false; // Reset victory flag
            
            // Reset wind system
            gameState.windStrength = 0;
            gameState.windAngle = 0;
            gameState.windChangeTimer = 0;
            gameState.windParticles = [];
            
            // Start marbles-specific timer (30 seconds)
            startMarblesTimer();
            
            // Play marbles music for this scene
            playSceneMusic('marbles');
            
            document.getElementById('instructions').textContent = 'CLICK and DRAG BACK to aim, then RELEASE to shoot marbles at the target! Watch out for wind effects! Need 25 points to survive! You have 30 seconds!';
        }

        function renderMarbles() {
            // Background - use marbscreen.png
            if (assets.marbscreen && assets.marbscreen.complete) {
                ctx.drawImage(assets.marbscreen, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw target in center
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Outer ring - red (1 point)
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 150, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Middle ring - yellow (3 points)
            ctx.strokeStyle = '#ffff00';
            ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Center ring - green (5 points - bullseye)
            ctx.strokeStyle = '#00ff00';
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw point values in rings
            ctx.fillStyle = 'white';
            ctx.font = '20px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('5pts', centerX, centerY + 5);
            ctx.fillText('3pts', centerX, centerY - 70);
            ctx.fillText('1pt', centerX, centerY - 120);
            
            // Draw enhanced aiming system with wind prediction
            drawAimingLine();
            
            // Update wind system
            updateWind();
            
            // Update and draw marbles
            updateMarbles();
            
            // Create and draw wind particles
            createWindParticles();
            
            // Draw floating score texts
            updateFloatingTexts();
            
            // Draw UI elements
            drawMarblesUI();
            
            // Draw wind indicator
            drawWindIndicator();
            
            // Check win/loss conditions
            checkMarblesWinLoss();
        }
        
        function updateMarbles() {
            for (let i = gameState.marbles.length - 1; i >= 0; i--) {
                const marble = gameState.marbles[i];
                
                if (marble.active) {
                    // Move marble
                    marble.x += marble.vx;
                    marble.y += marble.vy;
                    
                    // Only apply wind to marbles that are moving fast enough (prevents wind from affecting stopped marbles)
                    const currentSpeed = Math.sqrt(marble.vx * marble.vx + marble.vy * marble.vy);
                    if (currentSpeed > 1.5) { // Increased threshold so only fast marbles affected
                        // ADD WIND EFFECT (much more reduced strength)
                        marble.vx += Math.cos(gameState.windAngle) * gameState.windStrength * 0.003;
                        marble.vy += Math.sin(gameState.windAngle) * gameState.windStrength * 0.003;
                    }
                    
                    // Apply friction
                    marble.vx *= 0.96;
                    marble.vy *= 0.96;
                    
                    // Stop marble completely if moving very slowly to prevent wind from moving settled marbles
                    if (Math.abs(marble.vx) < 0.1 && Math.abs(marble.vy) < 0.1) {
                        marble.vx = 0;
                        marble.vy = 0;
                    }
                    
                    // Stop and score when slow or hits edge
                    if (Math.abs(marble.vx) < 0.1 && Math.abs(marble.vy) < 0.1 ||
                        marble.x < 10 || marble.x > canvas.width - 10 || 
                        marble.y < 10 || marble.y > canvas.height - 10) {
                        marble.active = false;
                        scoreMarble(marble);
                    }
                }
                
                // Draw marble using marble.png - BIGGER SIZE!
                if (assets.marble && assets.marble.complete) {
                    ctx.drawImage(assets.marble, marble.x - 15, marble.y - 15, 30, 30);
                } else {
                    // Fallback marble rendering - bigger
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(marble.x, marble.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function scoreMarble(marble) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const distance = Math.sqrt(
                Math.pow(marble.x - centerX, 2) + 
                Math.pow(marble.y - centerY, 2)
            );
            
            let points = 0;
            let color = 'white';
            if (distance <= 50) {
                points = 5;  // Center - green
                color = 'green';
                playBeep(1000, 0.3); // High beep for bullseye
            } else if (distance <= 100) {
                points = 3;  // Middle - yellow
                color = 'yellow';
                playBeep(800, 0.3); // Medium beep
            } else if (distance <= 150) {
                points = 1;  // Outer - red
                color = 'red';
                playBeep(600, 0.3); // Lower beep
            }
            
            if (points > 0) {
                gameState.marbleScore += points;
                addFloatingText(`+${points}`, marble.x, marble.y, color);
            }
        }
        
        function addFloatingText(text, x, y, color) {
            gameState.floatingTexts.push({
                text: text,
                x: x,
                y: y,
                color: color,
                alpha: 1.0,
                timer: 0
            });
        }
        
        // Wind System Functions
        function updateWind() {
            gameState.windChangeTimer++;
            
            // Change wind every 2-3 seconds (120-180 frames at 60fps)
            if (gameState.windChangeTimer > 120 + Math.random() * 60) {
                gameState.windChangeTimer = 0;
                
                // Progressive difficulty - stronger wind as more marbles are used
                updateWindDifficulty();
                
                // Random wind direction (any angle)
                gameState.windAngle = Math.random() * Math.PI * 2;
                
                console.log(`ðŸŒªï¸ Wind changed: Strength=${gameState.windStrength.toFixed(1)}, Angle=${(gameState.windAngle * 180 / Math.PI).toFixed(0)}Â°`);
            }
        }
        
        function updateWindDifficulty() {
            // More wind as player progresses through marbles (GENTLER DIFFICULTY)
            const marblesUsed = 10 - gameState.marblesLeft;
            
            if (marblesUsed > 7) {
                // Last few marbles have stronger wind
                gameState.windStrength = 0.5 + Math.random() * 1.0; // Max 1.5 instead of 3.5
            } else if (marblesUsed > 4) {
                // Medium wind for middle marbles  
                gameState.windStrength = 0.2 + Math.random() * 0.8; // Max 1.0 instead of 2.5
            } else {
                // Light wind for first marbles
                gameState.windStrength = Math.random() * 0.5; // Max 0.5 instead of 1.5
            }
        }
        
        function drawWindIndicator() {
            const windIndicatorX = canvas.width - 130;
            const windIndicatorY = canvas.height - 180; // Much lower position
            
            // Draw wind meter background - bigger and with border
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(canvas.width - 220, canvas.height - 250, 180, 160);
            
            // Add border for better visibility
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(canvas.width - 220, canvas.height - 250, 180, 160);
            
            // Title - larger font
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('WIND', windIndicatorX, canvas.height - 220);
            
            // Draw compass circle - much bigger
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(windIndicatorX, windIndicatorY, 50, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw compass points (N, S, E, W) for better orientation
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '12px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('N', windIndicatorX, windIndicatorY - 58);
            ctx.fillText('S', windIndicatorX, windIndicatorY + 66);
            ctx.fillText('E', windIndicatorX + 58, windIndicatorY + 4);
            ctx.fillText('W', windIndicatorX - 58, windIndicatorY + 4);
            
            // Draw wind arrow (shows direction and strength)
            if (gameState.windStrength > 0) {
                ctx.save();
                ctx.translate(windIndicatorX, windIndicatorY);
                ctx.rotate(gameState.windAngle);
                
                // Arrow color based on NEW REDUCED strength levels
                if (gameState.windStrength < 0.3) ctx.strokeStyle = '#32CD32'; // Lime green for very light
                else if (gameState.windStrength < 0.7) ctx.strokeStyle = '#FFD700'; // Gold for light
                else if (gameState.windStrength < 1.0) ctx.strokeStyle = '#FF8C00'; // Dark Orange for medium
                else ctx.strokeStyle = '#FF4500'; // Red Orange for strong
                
                // Arrow length based on strength - longer for visibility, with minimum length
                const arrowLength = Math.max(gameState.windStrength * 25, 10);
                
                // Draw arrow shaft - thicker
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(arrowLength, 0);
                ctx.stroke();
                
                // Arrow head - bigger and more visible
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(arrowLength, 0);
                ctx.lineTo(arrowLength - 10, -8);
                ctx.moveTo(arrowLength, 0);
                ctx.lineTo(arrowLength - 10, 8);
                ctx.stroke();
                
                // Add a glow effect around the arrow
                ctx.shadowColor = ctx.strokeStyle;
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                ctx.restore();
            } else {
                // No wind - show "CALM" - bigger and clearer
                ctx.fillStyle = '#32CD32'; // Lime green
                ctx.font = 'bold 16px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('CALM', windIndicatorX, windIndicatorY + 5);
            }
            
            // Wind strength text - larger and more prominent with better labels for new difficulty
            ctx.font = 'bold 18px Orbitron';
            ctx.textAlign = 'center';
            
            let windLabel, windColor;
            if (gameState.windStrength < 0.3) {
                windLabel = 'CALM';
                windColor = '#32CD32';
            } else if (gameState.windStrength < 0.7) {
                windLabel = 'LIGHT';
                windColor = '#FFD700';
            } else if (gameState.windStrength < 1.0) {
                windLabel = 'MEDIUM';
                windColor = '#FF8C00';
            } else {
                windLabel = 'STRONG';
                windColor = '#FF4500';
            }
            
            ctx.fillStyle = windColor;
            ctx.fillText(windLabel, windIndicatorX, canvas.height - 105);
            
            // Add numerical wind strength for extra clarity
            ctx.font = '14px Orbitron';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillText(`${gameState.windStrength.toFixed(1)}`, windIndicatorX, canvas.height - 85);
        }
        
        function createWindParticles() {
            // Create new particles occasionally - adjusted for new wind strength levels
            if (gameState.windStrength > 0.1 && Math.random() < gameState.windStrength * 0.15) {
                gameState.windParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    opacity: 0.5
                });
            }
            
            // Update and draw particles
            gameState.windParticles = gameState.windParticles.filter(particle => {
                // Move particle with wind
                particle.x += Math.cos(gameState.windAngle) * gameState.windStrength * 2;
                particle.y += Math.sin(gameState.windAngle) * gameState.windStrength * 2;
                particle.opacity -= 0.01;
                
                // Draw particle as small line
                ctx.strokeStyle = `rgba(255, 255, 255, ${particle.opacity})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(particle.x, particle.y);
                ctx.lineTo(
                    particle.x - Math.cos(gameState.windAngle) * 20,
                    particle.y - Math.sin(gameState.windAngle) * 20
                );
                ctx.stroke();
                
                // Keep if still visible
                return particle.opacity > 0 && 
                       particle.x > -50 && particle.x < canvas.width + 50 &&
                       particle.y > -50 && particle.y < canvas.height + 50;
            });
        }
        
        function drawAimingLine() {
            if (gameState.isAiming) {
                ctx.setLineDash([5, 5]);
                
                // Regular aim line (white)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(gameState.aimStartX, gameState.aimStartY);
                ctx.lineTo(gameState.currentMouseX, gameState.currentMouseY);
                ctx.stroke();
                
                // Predicted path with wind (red dotted line)
                if (gameState.windStrength > 0) {
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    // Calculate predicted curve
                    let predX = gameState.aimStartX;
                    let predY = gameState.aimStartY;
                    let predVx = (gameState.aimStartX - gameState.currentMouseX) * 0.15;
                    let predVy = (gameState.aimStartY - gameState.currentMouseY) * 0.15;
                    
                    ctx.moveTo(predX, predY);
                    
                    // Simulate trajectory with updated wind effect
                    for (let i = 0; i < 30; i++) {
                        // Only apply wind prediction if marble would be moving fast enough
                        const predSpeed = Math.sqrt(predVx * predVx + predVy * predVy);
                        if (predSpeed > 1.5) {
                            predVx += Math.cos(gameState.windAngle) * gameState.windStrength * 0.003;
                            predVy += Math.sin(gameState.windAngle) * gameState.windStrength * 0.003;
                        }
                        predVx *= 0.96;
                        predVy *= 0.96;
                        predX += predVx;
                        predY += predVy;
                        ctx.lineTo(predX, predY);
                    }
                    
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                
                // Draw power indicator when aiming
                const power = Math.min(
                    Math.sqrt(
                        Math.pow(gameState.currentMouseX - gameState.aimStartX, 2) + 
                        Math.pow(gameState.currentMouseY - gameState.aimStartY, 2)
                    ) / 10, 
                    10
                );
                
                // Power bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(canvas.width/2 - 100, canvas.height - 50, 200, 30);
                
                // Power bar fill
                ctx.fillStyle = `rgb(${power * 25}, ${255 - power * 25}, 0)`;
                ctx.fillRect(canvas.width/2 - 98, canvas.height - 48, power * 19.6, 26);
                
                // Power bar text
                ctx.fillStyle = 'white';
                ctx.font = '16px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('POWER', canvas.width/2, canvas.height - 30);
                
                // Wind effect warning text (adjusted threshold for new gentler difficulty)
                if (gameState.windStrength > 0.5) {
                    ctx.fillStyle = 'rgba(255, 150, 100, 0.9)';
                    ctx.font = 'bold 16px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText('ðŸŒªï¸ WIND ACTIVE - RED LINE SHOWS ACTUAL PATH ðŸŒªï¸', canvas.width/2, canvas.height - 70);
                }
            }
        }
        
        function updateFloatingTexts() {
            for (let i = gameState.floatingTexts.length - 1; i >= 0; i--) {
                const floatingText = gameState.floatingTexts[i];
                floatingText.timer++;
                floatingText.y -= 2; // Float upward
                floatingText.alpha = Math.max(0, 1 - floatingText.timer / 60); // Fade out
                
                // Draw floating text
                ctx.save();
                ctx.globalAlpha = floatingText.alpha;
                ctx.font = 'bold 24px Orbitron';
                ctx.fillStyle = floatingText.color;
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(floatingText.text, floatingText.x, floatingText.y);
                ctx.fillText(floatingText.text, floatingText.x, floatingText.y);
                ctx.restore();
                
                // Remove expired texts
                if (floatingText.alpha <= 0) {
                    gameState.floatingTexts.splice(i, 1);
                }
            }
        }
        
        function drawMarblesUI() {
            // Dark overlay bar at top
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, 60);
            
            ctx.fillStyle = 'white';
            ctx.font = '24px Orbitron';
            ctx.textAlign = 'left';
            
            // Marbles left
            ctx.fillText(`Marbles: ${gameState.marblesLeft}`, 20, 40);
            
            // Score
            ctx.textAlign = 'center';
            const scoreColor = gameState.marbleScore >= 25 ? '#00ff00' : '#ffffff';
            ctx.fillStyle = scoreColor;
            ctx.fillText(`Score: ${gameState.marbleScore}/25`, canvas.width/2, 40);
            
            // NO TIMER HERE - using HTML timerDisplay instead to avoid double timer
            
            // Draw visual marbles at bottom of screen
            drawMarbleInventory();
        }
        
        function checkMarblesWinLoss() {
            // WIN: Score >= 25 points
            if (gameState.marbleScore >= 25 && !gameState.marblesGameWon) {
                gameState.marblesGameWon = true; // Prevent multiple triggers
                clearInterval(gameState.timerInterval);
                
                // Green flash effect
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Victory text
                ctx.font = 'bold 48px Orbitron';
                ctx.fillStyle = '#00ff00';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText('CLEARED', canvas.width/2, canvas.height/2);
                ctx.fillText('CLEARED', canvas.width/2, canvas.height/2);
                
                ctx.font = 'bold 24px Orbitron';
                ctx.strokeText('Sharp shooter!', canvas.width/2, canvas.height/2 + 60);
                ctx.fillText('Sharp shooter!', canvas.width/2, canvas.height/2 + 60);
                
                // Play victory sounds ONCE
                initAudioContext();
                createBeep(523, 0.3, 'sine');
                setTimeout(() => createBeep(659, 0.3, 'sine'), 150);
                setTimeout(() => createBeep(784, 0.4, 'sine'), 300);
                setTimeout(() => createBeep(1047, 0.5, 'sine'), 450);
                
                // Show money falling effect and advance to memory shapes game after 2 seconds
                setTimeout(() => {
                    startMoneyFalling('memoryShapes');
                }, 2000);
                
                return;
            }
            
            // Show victory text if already won (but don't trigger sounds/transitions again)
            if (gameState.marblesGameWon) {
                // Green flash effect
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Victory text
                ctx.font = 'bold 48px Orbitron';
                ctx.fillStyle = '#00ff00';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText('CLEARED', canvas.width/2, canvas.height/2);
                ctx.fillText('CLEARED', canvas.width/2, canvas.height/2);
                
                ctx.font = 'bold 24px Orbitron';
                ctx.strokeText('Sharp shooter!', canvas.width/2, canvas.height/2 + 60);
                ctx.fillText('Sharp shooter!', canvas.width/2, canvas.height/2 + 60);
                
                return;
            }
            
            // LOSS: Timer runs out OR all marbles used with score < 25
            if ((gameTimer <= 0 || gameState.marblesLeft <= 0) && gameState.marbleScore < 25) {
                clearInterval(gameState.timerInterval);
                
                // Red flash effect
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Failure text
                ctx.font = 'bold 48px Orbitron';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText('ELIMINATED', canvas.width/2, canvas.height/2);
                ctx.fillText('ELIMINATED', canvas.width/2, canvas.height/2);
                
                ctx.font = 'bold 24px Orbitron';
                const reason = gameTimer <= 0 ? 'Time\'s up!' : 'Not enough points!';
                ctx.strokeText(reason, canvas.width/2, canvas.height/2 + 60);
                ctx.fillText(reason, canvas.width/2, canvas.height/2 + 60);
                
                // Play failure sound
                initAudioContext();
                createBeep(200, 1.0, 'square');
                
                // Restart marbles game after 2 seconds
                setTimeout(() => {
                    gameOver('Target practice failed!');
                }, 2000);
            }
        }
        
        function drawMarbleInventory() {
            // Show remaining marbles visually at bottom of screen - HIGHER UP!
            const marbleSize = 25;
            const spacing = 35;
            const totalWidth = gameState.marblesLeft * spacing;
            const startX = (canvas.width - totalWidth) / 2;
            const y = canvas.height - 120; // Moved much higher so instructions don't cover it
            
            // Dark background for marble inventory
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(startX - 20, y - marbleSize/2 - 10, totalWidth + 40, marbleSize + 20);
            
            // Draw each remaining marble
            for (let i = 0; i < gameState.marblesLeft; i++) {
                const x = startX + i * spacing;
                
                if (assets.marble && assets.marble.complete) {
                    ctx.drawImage(assets.marble, x - marbleSize/2, y - marbleSize/2, marbleSize, marbleSize);
                } else {
                    // Fallback marble
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(x, y, marbleSize/2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Label
            ctx.font = '16px Orbitron';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('Remaining Marbles', canvas.width / 2, y + marbleSize/2 + 25);
        }
        
        function playBeep(frequency, duration) {
            initAudioContext();
            createBeep(frequency, duration, 'sine');
        }

        function setupMemoryShapes() {
            console.log('MEMORY SHAPES SETUP: Starting memory game');
            
            // Reset memory game state
            gameState.memoryCurrentRound = 1;
            gameState.memorySequence = [];
            gameState.memoryPlayerSequence = [];
            gameState.memoryIsShowingSequence = false;
            gameState.memoryIsPlayerTurn = false;
            gameState.memorySequenceIndex = 0;
            gameState.memoryGameWon = false;
            
            // Clear any existing timers
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            document.getElementById('instructions').textContent = 'MEMORY SHAPES: Watch the sequence and repeat it exactly! One mistake = elimination!';
            
            // Start first round after brief delay
            setTimeout(() => {
                startMemoryRound();
            }, 1500);
        }

        function startMemoryRound() {
            const roundData = gameState.memoryRounds[gameState.memoryCurrentRound - 1];
            
            // CRITICAL: Reset all round state
            gameState.memorySequence = [];
            gameState.memoryPlayerSequence = [];
            gameState.memoryIsShowingSequence = false;
            gameState.memoryIsPlayerTurn = false;
            gameState.memorySequenceIndex = -1;
            
            console.log(`ðŸ§  === STARTING ROUND ${gameState.memoryCurrentRound} ===`);
            console.log(`ðŸ§  Sequence length: ${roundData.length}, speed: ${roundData.speed}ms`);
            
            // Generate random sequence
            for (let i = 0; i < roundData.length; i++) {
                gameState.memorySequence.push(Math.floor(Math.random() * 4));
            }
            
            console.log(`ðŸ§  Generated sequence: [${gameState.memorySequence.join(', ')}]`);
            
            // After 3 seconds, show the sequence
            setTimeout(() => {
                showMemorySequence();
            }, 3000);
        }

        function showMemorySequence() {
            console.log(`ðŸ§  === SHOWING SEQUENCE ===`);
            console.log(`ðŸ§  Sequence to show: [${gameState.memorySequence.join(', ')}]`);
            
            gameState.memoryIsShowingSequence = true;
            gameState.memoryIsPlayerTurn = false;
            gameState.memorySequenceIndex = -1;
            let index = 0;
            const roundData = gameState.memoryRounds[gameState.memoryCurrentRound - 1];
            
            const interval = setInterval(() => {
                if (index < gameState.memorySequence.length) {
                    // Highlight current shape and play tone
                    const shapeIndex = gameState.memorySequence[index];
                    const currentStep = index + 1; // Capture current step
                    const isLastShape = (currentStep === gameState.memorySequence.length);
                    
                    console.log(`ðŸ§  Showing shape ${shapeIndex} (step ${currentStep}/${gameState.memorySequence.length}) ${isLastShape ? '[LAST]' : ''}`);
                    playMemoryTone(shapeIndex);
                    
                    // Store which shape to highlight for rendering
                    gameState.memorySequenceIndex = shapeIndex;
                    
                    // Stop highlighting after a consistent duration for ALL shapes
                    setTimeout(() => {
                        console.log(`ðŸ§  Turning off highlight for shape ${shapeIndex}`);
                        gameState.memorySequenceIndex = -1;
                    }, roundData.speed * 0.7); // Consistent timing for all shapes
                    
                    index++;
                } else {
                    // Sequence complete - player's turn
                    clearInterval(interval);
                    gameState.memoryIsShowingSequence = false;
                    gameState.memoryIsPlayerTurn = true;
                    gameState.memorySequenceIndex = -1; // No highlight
                    
                    console.log('ðŸ§  === PLAYER TURN - REPEAT THE SEQUENCE ===');
                    console.log(`ðŸ§  Expected sequence: [${gameState.memorySequence.join(', ')}]`);
                }
            }, roundData.speed);
        }

        function playMemoryTone(shapeIndex) {
            const frequencies = [261, 329, 392, 523]; // C, E, G, High C
            initAudioContext();
            console.log(`ðŸ”Š Playing tone for shape ${shapeIndex}, frequency: ${frequencies[shapeIndex]}`);
            createBeep(frequencies[shapeIndex], 0.3, 'sine'); // Longer duration for better feedback
        }

        function handleMemoryShapeClick(clickX, clickY) {
            if (!gameState.memoryIsPlayerTurn) {
                console.log('ðŸ§  Click ignored - not player turn');
                return;
            }
            
            console.log(`ðŸ§  Click at (${clickX}, ${clickY})`);
            
            // Check which shape was clicked
            for (let i = 0; i < gameState.memoryShapes.length; i++) {
                const shape = gameState.memoryShapes[i];
                const dist = Math.sqrt(Math.pow(clickX - shape.x, 2) + Math.pow(clickY - shape.y, 2));
                
                console.log(`ðŸ§  Shape ${i} (${shape.type}) at (${shape.x}, ${shape.y}), distance: ${dist}`);
                
                if (dist < 70) { // Shape clicked
                    const currentIndex = gameState.memoryPlayerSequence.length;
                    const expectedShape = gameState.memorySequence[currentIndex];
                    
                    console.log(`ðŸ§  Player clicked shape ${i} (${shape.type})`);
                    console.log(`ðŸ§  Current sequence position: ${currentIndex}`);
                    console.log(`ðŸ§  Expected shape: ${expectedShape}, clicked shape: ${i}`);
                    console.log(`ðŸ§  Full sequence: [${gameState.memorySequence.join(', ')}]`);
                    console.log(`ðŸ§  Player sequence so far: [${gameState.memoryPlayerSequence.join(', ')}]`);
                    
                    // Flash the shape brightly and play sound
                    gameState.memorySequenceIndex = i;
                    playMemoryTone(i);
                    
                    setTimeout(() => {
                        gameState.memorySequenceIndex = -1;
                    }, 300);
                    
                    gameState.memoryPlayerSequence.push(i);
                    
                    // Check if correct
                    if (i !== expectedShape) {
                        // WRONG! Elimination
                        console.log(`ðŸ§  WRONG! Expected ${expectedShape}, got ${i}`);
                        setTimeout(() => memoryGameOver(), 500);
                    } else if (gameState.memoryPlayerSequence.length === gameState.memorySequence.length) {
                        // Round complete!
                        console.log('ðŸ§  Round completed successfully!');
                        setTimeout(() => memoryRoundComplete(), 500);
                    } else {
                        console.log('ðŸ§  Correct! Continue...');
                    }
                    
                    break;
                }
            }
        }

        function memoryRoundComplete() {
            console.log(`ðŸ§  === ROUND ${gameState.memoryCurrentRound} COMPLETED! ===`);
            
            gameState.memoryIsPlayerTurn = false;
            gameState.memoryIsShowingSequence = false;
            gameState.memorySequenceIndex = -1;
            
            // Play success sound
            initAudioContext();
            createBeep(523, 0.3, 'sine');
            setTimeout(() => createBeep(659, 0.3, 'sine'), 150);
            setTimeout(() => createBeep(784, 0.4, 'sine'), 300);
            
            if (gameState.memoryCurrentRound < 5) {
                console.log(`ðŸ§  Moving to round ${gameState.memoryCurrentRound + 1}`);
                gameState.memoryCurrentRound++;
                setTimeout(() => startMemoryRound(), 2000);
            } else {
                // ALL ROUNDS COMPLETE - WINNER!
                console.log('ðŸ§  ALL ROUNDS COMPLETE - VICTORY!');
                setTimeout(() => memoryVictory(), 1500);
            }
        }

        function memoryVictory() {
            if (gameState.memoryGameWon) return; // Prevent multiple triggers
            gameState.memoryGameWon = true;
            
            console.log('ðŸ§  MEMORY GAME COMPLETED! Perfect memory!');
            
            // Play victory sounds
            initAudioContext();
            createBeep(523, 0.3, 'sine');
            setTimeout(() => createBeep(659, 0.3, 'sine'), 150);
            setTimeout(() => createBeep(784, 0.4, 'sine'), 300);
            setTimeout(() => createBeep(1047, 0.5, 'sine'), 450);
            
            // Advance to final victory screen with money falling after 3 seconds
            setTimeout(() => {
                startMoneyFalling('finalscreen');
            }, 3000);
        }

        function memoryGameOver() {
            gameState.memoryIsPlayerTurn = false;
            
            // Play failure sound
            initAudioContext();
            createBeep(200, 1.0, 'square');
            
            // Game over after 2 seconds
            setTimeout(() => {
                gameOver('Wrong sequence! Memory failed!');
            }, 2000);
        }

        function renderMemoryShapes() {
            // Draw background first
            if (assets.memoryback && assets.memoryback.complete) {
                ctx.drawImage(assets.memoryback, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw UI overlay at top
            drawMemoryUI();
            
            // Draw all shapes
            gameState.memoryShapes.forEach((shape, index) => {
                const isActive = (gameState.memorySequenceIndex === index);
                drawMemoryShape(shape, isActive);
            });
            
            // Show round announcement
            if (!gameState.memoryIsShowingSequence && !gameState.memoryIsPlayerTurn && !gameState.memoryGameWon) {
                const roundData = gameState.memoryRounds[gameState.memoryCurrentRound - 1];
                
                // Dark overlay for text visibility
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(`ROUND ${gameState.memoryCurrentRound}`, canvas.width/2, canvas.height/2 - 30);
                
                ctx.font = '32px Orbitron';
                ctx.fillStyle = 'yellow';
                ctx.fillText(roundData.description, canvas.width/2, canvas.height/2 + 30);
            }
            
            // Show "YOUR TURN" message during player turn
            if (gameState.memoryIsPlayerTurn) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(canvas.width/2 - 200, 50, 400, 60);
                ctx.fillStyle = 'cyan';
                ctx.font = 'bold 28px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('YOUR TURN - REPEAT THE SEQUENCE', canvas.width/2, 85);
            }
            
            // Show victory screen if game won
            if (gameState.memoryGameWon) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 4;
                ctx.font = 'bold 56px Orbitron';
                ctx.textAlign = 'center';
                ctx.strokeText('CLEARED', canvas.width/2, canvas.height/2 - 30);
                ctx.fillText('CLEARED', canvas.width/2, canvas.height/2 - 30);
                
                ctx.font = '32px Orbitron';
                ctx.fillText('Perfect Memory!', canvas.width/2, canvas.height/2 + 30);
            }
        }

        function drawMemoryUI() {
            // Top bar with transparent black background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, 80);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Orbitron';
            ctx.textAlign = 'left';
            ctx.fillText(`ROUND ${gameState.memoryCurrentRound}/5`, 20, 35);
            
            ctx.font = '18px Orbitron';
            ctx.fillText(`Sequence Length: ${gameState.memoryRounds[gameState.memoryCurrentRound-1].length}`, 20, 60);
            
            // Progress indicators
            for (let i = 0; i < 5; i++) {
                ctx.fillStyle = i < gameState.memoryCurrentRound ? '#44ff44' : '#444';
                ctx.fillRect(canvas.width - 200 + (i * 35), 25, 30, 30);
                
                // Round number
                ctx.fillStyle = 'white';
                ctx.font = '16px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(i + 1, canvas.width - 185 + (i * 35), 45);
            }
        }

        function drawMemoryShape(shape, isActive = false) {
            // Semi-transparent backing for visibility on background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(shape.x, shape.y, 70, 0, Math.PI * 2);
            ctx.fill();
            
            // Add glowing effect if active
            if (isActive) {
                ctx.shadowColor = shape.activeColor;
                ctx.shadowBlur = 30;
                ctx.globalAlpha = 1.0;
            } else {
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
            
            // Draw the actual shape
            ctx.fillStyle = isActive ? shape.activeColor : shape.color;
            ctx.strokeStyle = isActive ? '#ffffff' : '#cccccc';
            ctx.lineWidth = isActive ? 5 : 3;
            
            switch(shape.type) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(shape.x, shape.y, 60, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;
                    
                case 'square':
                    ctx.fillRect(shape.x - 60, shape.y - 60, 120, 120);
                    ctx.strokeRect(shape.x - 60, shape.y - 60, 120, 120);
                    break;
                    
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(shape.x, shape.y - 60);
                    ctx.lineTo(shape.x - 60, shape.y + 60);
                    ctx.lineTo(shape.x + 60, shape.y + 60);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                    
                case 'star':
                    ctx.beginPath();
                    for (let i = 0; i < 10; i++) {
                        const radius = (i % 2 === 0) ? 60 : 30;
                        const angle = (Math.PI * 2 * i) / 10 - Math.PI / 2;
                        const x = shape.x + Math.cos(angle) * radius;
                        const y = shape.y + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
            }
            
            // Reset shadow and alpha
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1.0;
        }

        function renderGameOver() {
            // Dark red death background
            ctx.fillStyle = '#1a0505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Flashing red overlay
            const flashTime = Date.now() / 300;
            const flash = Math.sin(flashTime) * 0.2 + 0.3;
            ctx.fillStyle = `rgba(255, 0, 0, ${flash})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Death screen elements
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(150, 200, canvas.width - 300, canvas.height - 400);
            
            // Crossed out 67
            ctx.font = 'bold 120px Orbitron';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('67', canvas.width / 2, canvas.height / 2 - 80);
            
            // Red X over number with animation
            const xOffset = Math.sin(Date.now() / 200) * 2;
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 10;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff0000';
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2 - 80 + xOffset, canvas.height / 2 - 140);
            ctx.lineTo(canvas.width / 2 + 80 + xOffset, canvas.height / 2 - 20);
            ctx.moveTo(canvas.width / 2 + 80 + xOffset, canvas.height / 2 - 140);
            ctx.lineTo(canvas.width / 2 - 80 + xOffset, canvas.height / 2 - 20);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // DEAD text
            ctx.font = 'bold 72px Orbitron';
            ctx.fillStyle = '#ff0000';
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff0000';
            ctx.fillText('DEAD', canvas.width / 2, canvas.height / 2 + 60);
            ctx.shadowBlur = 0;
            
            // Instructions
            ctx.font = 'bold 24px Orbitron';
            ctx.fillStyle = '#fff';
            const instructionFlash = Math.sin(Date.now() / 500) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 255, 255, ${instructionFlash})`;
            ctx.fillText('Click or Press Any Key to Try Again', canvas.width / 2, canvas.height / 2 + 120);
            
            // Retry notice based on current scene
            ctx.font = 'bold 16px Orbitron';
            ctx.fillStyle = '#ffaa00';
            let retryText = '(Restarting current game)';
            if (gameState.lastScene === 'redLightGreenLight') {
                retryText = '(Restarting Red Light Green Light)';
            } else if (gameState.lastScene === 'honeycomb') {
                retryText = '(Restarting Honeycomb Game)';
            } else if (gameState.lastScene === 'glassBridge') {
                retryText = '(Restarting Glass Bridge)';
            }
            ctx.fillText(retryText, canvas.width / 2, canvas.height / 2 + 150);
        }

        function renderWin() {
            ctx.fillStyle = '#0a2a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Spotlight on money
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 300);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Money pile
            ctx.fillStyle = '#00ff00';
            for (let i = 0; i < 20; i++) {
                const x = centerX - 100 + Math.random() * 200;
                const y = centerY - 50 + Math.random() * 100;
                ctx.fillRect(x, y, 30, 15);
            }
            
            // Diploma on top
            ctx.fillStyle = '#fff';
            ctx.fillRect(centerX - 60, centerY - 80, 120, 80);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 16px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('ALPHA DIPLOMA', centerX, centerY - 50);
            ctx.fillText('Student #67', centerX, centerY - 30);
            
            ctx.font = 'bold 48px Orbitron';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('YOU SURVIVED', canvas.width / 2, 200);
            
            ctx.font = 'bold 32px Orbitron';
            ctx.fillText('Prize: $67,670,000', canvas.width / 2, 300);
            
            ctx.font = 'bold 24px Orbitron';
            ctx.fillStyle = '#fff';
            ctx.fillText('Thank you for your participation, Contestant 67.', canvas.width / 2, 650);
        }

        function renderFinalScreen() {
            // Display the victory.png image as background
            if (assets.victory && assets.victory.complete) {
                ctx.drawImage(assets.victory, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback black background if image doesn't load
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Player completion time
            if (gameState.playerCompletionTime > 0) {
                ctx.font = 'bold 24px Orbitron';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#000';
                ctx.fillText(`Your Time: ${formatTime(gameState.playerCompletionTime)}`, canvas.width / 2, 120);
            }
            
            // ðŸ† LEADERBOARD DISPLAY ðŸ†
            if (gameState.currentLeaderboard && gameState.currentLeaderboard.length > 0) {
                // Leaderboard title
                ctx.font = 'bold 28px Orbitron';
                ctx.fillStyle = '#ffd700';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#000';
                ctx.fillText('ðŸ† LEADERBOARD ðŸ†', canvas.width / 2, 160);
                
                // Leaderboard background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width / 2 - 300, 180, 600, Math.min(gameState.currentLeaderboard.length * 30 + 20, 300));
                
                // Leaderboard entries
                ctx.font = 'bold 18px Orbitron';
                ctx.textAlign = 'left';
                ctx.shadowBlur = 5;
                
                gameState.currentLeaderboard.slice(0, 10).forEach((entry, index) => {
                    const y = 205 + index * 30;
                    const isCurrentPlayer = entry.name === gameState.playerName && Math.abs(entry.time - gameState.playerCompletionTime) < 0.1;
                    
                    // Highlight current player
                    if (isCurrentPlayer) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                        ctx.fillRect(canvas.width / 2 - 290, y - 20, 580, 25);
                        ctx.fillStyle = '#ffd700';
                        ctx.shadowColor = '#000';
                    } else {
                        ctx.fillStyle = '#fff';
                        ctx.shadowColor = '#000';
                    }
                    
                    // Rank
                    ctx.textAlign = 'right';
                    ctx.fillText(`${index + 1}.`, canvas.width / 2 - 250, y);
                    
                    // Name (truncated if too long)
                    const displayName = entry.name.length > 20 ? entry.name.substring(0, 20) + '...' : entry.name;
                    ctx.textAlign = 'left';
                    ctx.fillText(displayName, canvas.width / 2 - 230, y);
                    
                    // Time
                    ctx.textAlign = 'right';
                    ctx.fillText(formatTime(entry.time), canvas.width / 2 + 280, y);
                });
            }
            
            ctx.shadowBlur = 0;
        }

        // Input Handling
        function handleKeyDown(e) {
            // Debug mode toggle (always available)
            if (e.key.toLowerCase() === 'h') {
                toggleDebugMode();
                return;
            }
            
            // Prevent any input while death video is playing
            const deathVideoContainer = document.getElementById('deathVideoContainer');
            if (deathVideoContainer && deathVideoContainer.style.display === 'block') {
                e.preventDefault();
                return;
            }
            
            // Debug input handling (takes priority when active)
            if (gameState.debugMode) {
                handleDebugInput(e.key);
                if (gameState.debugMenuOpen) return; // Block game input when menu is open
            }
            
            // Ignore input if game is paused (during money falling)
            if (gameState.isPaused) return;
            
            gameState.keys[e.key.toLowerCase()] = true;
            
            // Scene-specific key handling
            if (currentScene === 'mainMenu') {
                if (e.key === 'Enter' || e.key === ' ') {
                    playMenuBeep();
                    showScene('intro');
                }
            } else if (currentScene === 'intro') {
                if (gameState.introStage === 2) { // All text shown, ready to proceed
                    showScene('redLightGreenLight');
                } else if (gameState.introStage === 1) { // Text is showing, speed it up
                    advanceIntroText();
                }
            } else if (currentScene === 'redLightGreenLight') {
                handleRedLightMovement(e.key);
            } else if (currentScene === 'glassBridge') {
                handleBridgeMovement(e.key);
            } else if (currentScene === 'gameOver') {
                // Restart from last played game scene with fresh timer
                gameState.gameStartTime = null; // Reset leaderboard timer for new attempt
                const restartScene = gameState.lastScene || 'redLightGreenLight';
                showScene(restartScene);
            } else if (currentScene === 'win') {
                showScene('mainMenu');
            } else if (currentScene === 'finalscreen') {
                // Handle SPACE for JSON download, any other key for main menu
                if (e.key === ' ' || e.key === 'Space') {
                    downloadLeaderboardJSON();
                } else {
                    showScene('mainMenu');
                }
            }
        }

        function handleKeyUp(e) {
            // Prevent any input while death video is playing
            const deathVideoContainer = document.getElementById('deathVideoContainer');
            if (deathVideoContainer && deathVideoContainer.style.display === 'block') {
                e.preventDefault();
                return;
            }
            
            // Ignore input if game is paused (during money falling)
            if (gameState.isPaused) return;
            
            gameState.keys[e.key.toLowerCase()] = false;
            
            // Handle red light green light movement tracking
            if (currentScene === 'redLightGreenLight') {
                const releasedKey = e.key.toLowerCase();
                const isMovementKey = ['d', 'arrowright', 'a', 'arrowleft', 'w', 'arrowup', 's', 'arrowdown'].includes(releasedKey);
                
                if (isMovementKey) {
                    // Remove the released key from movement keys set
                    gameState.movementKeys.delete(releasedKey);
                    // Update isMoving based on whether any movement keys are still pressed
                    gameState.isMoving = gameState.movementKeys.size > 0;
                }
            }
        }

        function handleRedLightMovement(key) {
            let moved = false;
            const finishLineX = canvas.width - 200; // Same as in render
            
            // Calculate current movement speed - constant speed regardless of scale
            const baseSpeed = 8;
            const currentSpeed = baseSpeed; // Constant speed - no exponential slowdown
            
            // Check if this is a movement key first
            const isMovementKey = ['d', 'arrowright', 'a', 'arrowleft', 'w', 'arrowup', 's', 'arrowdown'].includes(key.toLowerCase());
            
            // During red light, handle movement key presses
            if (isMovementKey && !gameState.isGreenLight) {
                // Track that a movement key is being pressed
                gameState.movementKeys.add(key.toLowerCase());
                gameState.isMoving = gameState.movementKeys.size > 0;
                return; // Don't actually move the player
            }
            
            // Track movement keys during green light too
            if (isMovementKey) {
                gameState.movementKeys.add(key.toLowerCase());
            }
            
            // Only process movement keys during green light
            if (isMovementKey && gameState.isGreenLight) {
                switch(key.toLowerCase()) {
                    case 'd':
                    case 'arrowright':
                        // Move RIGHT toward Chloe (main movement direction)
                        if (gameState.playerPosition.x < finishLineX - 60) {
                            gameState.playerPosition.x += currentSpeed;
                            moved = true;
                        }
                        break;
                    case 'a':
                    case 'arrowleft':
                        // Move LEFT (back toward start)
                        if (gameState.playerPosition.x > 120) {
                            gameState.playerPosition.x -= currentSpeed;
                            moved = true;
                        }
                        break;
                    case 'w':
                    case 'arrowup':
                        // Move UP within classroom bounds
                        if (gameState.playerPosition.y > 180) {
                            gameState.playerPosition.y -= currentSpeed * 0.5; // Slower vertical movement
                            moved = true;
                        }
                        break;
                    case 's':
                    case 'arrowdown':
                        // Move DOWN within classroom bounds
                        if (gameState.playerPosition.y < canvas.height - 180) {
                            gameState.playerPosition.y += currentSpeed * 0.5; // Slower vertical movement
                            moved = true;
                        }
                        break;
                }
            }

            if (moved) {
                // Don't set isMoving during green light - only track it during red
                // gameState.isMoving = true; // REMOVED - this was causing false deaths
                
                // Check for obstacle collision
                checkObstacleCollision();
                
                // Check if reached finish line (horizontal distance)
                if (gameState.playerPosition.x >= finishLineX - 60) {
                    // Player wins Red Light Green Light!
                    console.log('Player reached finish line in Red Light Green Light!');
                    
                    // Clear ALL intervals to prevent stuck timers
                    if (gameState.timerInterval) {
                        clearInterval(gameState.timerInterval);
                        gameState.timerInterval = null;
                    }
                    if (gameState.lightInterval) {
                        clearInterval(gameState.lightInterval);
                        gameState.lightInterval = null;
                    }
                    if (gameState.redLightCheckInterval) {
                        clearInterval(gameState.redLightCheckInterval);
                        gameState.redLightCheckInterval = null;
                    }
                    
                    gameState.isMoving = false; // Stop movement
                    gameState.movementKeys.clear(); // Clear movement keys
                    
                    // Smooth transition to honeycomb with victory fanfare and money celebration
                    playVictoryFanfare();
                    startMoneyFalling('honeycomb'); // Start money falling effect, then go to honeycomb
                    // No setTimeout needed - money effect will handle scene transition
                }
            }
        }

        function handleBridgeMovement(key) {
            if (key === ' ' && gameState.selectedTile !== null) {
                if (gameState.bridgePosition.row < 0) {
                    // First jump - from starting position to selected tile
                    gameState.bridgePosition.row = gameState.selectedTile.row;
                    gameState.bridgePosition.col = gameState.selectedTile.col;
                    gameState.selectedTile = null; // Clear selection
                    checkTileBreak();
                } else {
                    // Move to next row - can only move upward (to higher row numbers)
                    const targetRow = gameState.selectedTile.row;
                    const targetCol = gameState.selectedTile.col;
                    
                    if (targetRow === gameState.bridgePosition.row + 1) {
                        gameState.bridgePosition.row = targetRow;
                        gameState.bridgePosition.col = targetCol;
                        gameState.selectedTile = null; // Clear selection
                        
                        if (targetRow >= 9) {
                            // Reached the end (row 9 is the last row)! Go to marbles game
                            clearInterval(gameState.timerInterval);
                            setTimeout(() => startMoneyFalling('marbles'), 1000);
                        } else {
                            checkTileBreak();
                        }
                    }
                }
            }
        }

        function checkTileBreak() {
            const { row, col } = gameState.bridgePosition;
            const isSafe = gameState.safeTiles[row] === col;
            
            if (!isSafe) {
                playGlassBreak();
                gameOver('Glass tile shattered!');
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            
            // Initialize mousePos if it doesn't exist
            if (!gameState.mousePos) {
                gameState.mousePos = { x: 0, y: 0 };
            }
            
            gameState.mousePos.x = e.clientX - rect.left;
            gameState.mousePos.y = e.clientY - rect.top;
            
            // Ignore tracing input if game is paused (during money falling)
            if (gameState.isPaused) return;
            
            if (currentScene === 'marbles') {
                // Update mouse position for aiming
                if (gameState.isAiming) {
                    gameState.currentMouseX = gameState.mousePos.x;
                    gameState.currentMouseY = gameState.mousePos.y;
                }
            } else if (currentScene === 'honeycomb') {
                // Phase 5: Check tracing with normal mouse cursor
                if (gameState.shellGamePhase === 5 && gameState.tracingActive) {
                    checkShellGameTrace();
                }
            }
        }

        function handleMouseDown(e) {
            // Prevent any input while death video is playing
            const deathVideoContainer = document.getElementById('deathVideoContainer');
            if (deathVideoContainer && deathVideoContainer.style.display === 'block') {
                e.preventDefault();
                return;
            }
            
            // Ignore input if game is paused (during money falling)
            if (gameState.isPaused) return;
            
            if (currentScene === 'mainMenu') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check START area - click anywhere on the start button or press enter
                if (x >= canvas.width/2 - 150 && x <= canvas.width/2 + 150 && y >= 520 && y <= 580) {
                    playMenuBeep();
                    showScene('intro');
                }
            } else if (currentScene === 'intro') {
                // Click anywhere to advance intro text
                if (gameState.introStage === 2) { // All text shown, ready to proceed
                    showScene('redLightGreenLight');
                } else if (gameState.introStage === 1) { // Text is showing, speed it up
                    advanceIntroText();
                }
            } else if (currentScene === 'gameOver') {
                // Click to restart from last played game scene with fresh timer
                gameState.gameStartTime = null; // Reset leaderboard timer for new attempt
                const restartScene = gameState.lastScene || 'redLightGreenLight';
                showScene(restartScene);
            } else if (currentScene === 'finalscreen') {
                // Click to return to main menu (no JSON download on click)
                showScene('mainMenu');
            } else if (currentScene === 'honeycomb') {
                gameState.isMouseDown = true; // Track mouse down for tracing
                handleShellGameClick(e);
            } else if (currentScene === 'marbles') {
                // Start aiming for marble shooting
                if (gameState.marblesLeft > 0 && !gameState.isAiming) {
                    const rect = canvas.getBoundingClientRect();
                    gameState.isAiming = true;
                    gameState.aimStartX = e.clientX - rect.left;
                    gameState.aimStartY = e.clientY - rect.top;
                    gameState.currentMouseX = gameState.aimStartX;
                    gameState.currentMouseY = gameState.aimStartY;
                }
            } else if (currentScene === 'memoryShapes') {
                // Handle memory shape clicking
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                handleMemoryShapeClick(clickX, clickY);
            } else if (currentScene === 'glassBridge') {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // Check if clicking on a tile - 10 rows x 2 columns (MUST match render sizes!)
                const tileWidth = 120;
                const tileHeight = 60;
                const totalTileWidth = tileWidth * 2; // Two tiles side by side
                const startX = (canvas.width - totalTileWidth) / 2; // Perfect center
                const startY = 100; // Start position
                const availableHeight = canvas.height - startY - 50; // Leave 50px at bottom
                const rowSpacing = availableHeight / 10; // MUST match rendering exactly!
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 2; col++) {
                        const tileX = startX + col * tileWidth;
                        const tileY = startY + row * rowSpacing;
                        
                                                // Check if click is within this tile
                        if (clickX >= tileX && clickX <= tileX + tileWidth &&
                            clickY >= tileY && clickY <= tileY + tileHeight) {
                            
                            // Allow tile selection with proper rules
                            if (gameState.bridgePosition.row < 0 && row === 0) {
                                // Starting - can select first row only
                                gameState.selectedTile = { row, col };
                                playMenuBeep();
                            } else if (gameState.bridgePosition.row >= 0 && row === gameState.bridgePosition.row + 1) {
                                // On bridge - can select next row only
                                gameState.selectedTile = { row, col };
                                playMenuBeep();
                            }
                    return;
                        }
                    }
                }
            }
        }



        // Shell Game Click Handler
        function handleShellGameClick(e) {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            switch(gameState.shellGamePhase) {
                case 4: // Box selection phase
                    handleBoxSelection(clickX, clickY);
                    break;
                case 5: // Tracing phase - only start if clicking on cookie
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const size = 300;
                    const isOnCookie = isPointOnCookieOutline(gameState.selectedCookie, clickX, clickY, centerX, centerY, size);
                    
                    if (isOnCookie) {
                        gameState.tracingActive = true;
                        console.log('ðŸª Tracing activated! Hold down and drag to trace.');
                    } else {
                        console.log('ðŸª Click on the cookie outline to start tracing!');
                    }
                    break;
            }
        }

        function handleBoxSelection(clickX, clickY) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Check which box was clicked
            for (let i = 0; i < gameState.boxes.length; i++) {
                const box = gameState.boxes[i];
                const boxX = centerX + box.x - 50;
                const boxY = centerY + box.y - 50;
                
                if (clickX >= boxX && clickX <= boxX + 100 &&
                    clickY >= boxY && clickY <= boxY + 100) {
                    
                    // Box selected!
                    gameState.selectedBox = i;
                    const selectedCookie = box.cookie;
                    
                    console.log(`ðŸŽ¯ Selected box ${i} containing ${selectedCookie}`);
                    
                    // Play selection sound
                    initAudioContext();
                    createBeep(523, 0.3);
                    
                    // Start Phase 5 with chosen cookie
                    setTimeout(() => {
                        startPhase5(selectedCookie);
                    }, 1000);
                    
                    break;
                }
            }
        }

        function checkShellGameTrace() {
            if (!gameState.tracingActive || !gameState.selectedCookie) return;
            
            const mouseX = gameState.mousePos.x;
            const mouseY = gameState.mousePos.y;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const size = 300;
            
            // Check if mouse is on the cookie outline
            const isOnOutline = isPointOnCookieOutline(gameState.selectedCookie, mouseX, mouseY, centerX, centerY, size);
            
            console.log(`ðŸª Mouse at (${mouseX}, ${mouseY}) - On outline: ${isOnOutline}, Mouse down: ${gameState.isMouseDown}`);
            
            // Only trace when mouse is held down
            if (gameState.isMouseDown) {
                if (isOnOutline) {
                    // Successfully tracing on outline
                    if (!gameState.tracingStarted) {
                        gameState.tracingStarted = true;
                        console.log('ðŸª Started tracing!');
                    }
                    
                    // Add to trace path (avoid duplicates)
                    const lastPoint = gameState.tracePath[gameState.tracePath.length - 1];
                    if (!lastPoint || Math.abs(lastPoint.x - mouseX) > 3 || Math.abs(lastPoint.y - mouseY) > 3) {
                        gameState.tracePath.push({x: mouseX, y: mouseY});
                        
                        // COMPREHENSIVE outline coverage tracking - must drag across actual outline!
                        updateOutlineCoverage();
                        
                        console.log(`ðŸª Progress: ${Math.floor(gameState.traceProgress * 100)}% - Must drag across entire outline!`);
                        
                        // Check for completion - MUST cover 90% of actual outline (easier for backpack)!
                        if (gameState.traceProgress >= 0.90) {
                            console.log('ðŸŽ‰ HONEYCOMB COMPLETED! 90%+ of outline traced - transitioning to Glass Bridge!');
                            gameState.honeycombComplete = true;
                            clearInterval(gameState.timerInterval);
                            gameState.tracingActive = false;
                            
                            // Restore default cursor
                            canvas.style.cursor = 'default';
                            
                            // Victory!
                            playVictoryFanfare();
                            startMoneyFalling('glassBridge');
                        }
                    }
                } else if (gameState.tracingStarted) {
                    // Mouse went off outline while tracing - BREAK THE COOKIE!
                    console.log('ðŸ’¥ Cookie cracked! Went off outline while tracing!');
                    playCrackSound();
                    canvas.style.cursor = 'default';
                    gameOver('Cookie cracked! You must stay exactly on the outline!');
                }
            }
        }

        function isPointOnCookieOutline(cookieType, x, y, centerX, centerY, size) {
            // Use exact PNG outline detection with 25-pixel tolerance for easier tracing
            return isOnPNGOutline(x, y, cookieType, centerX, centerY, size, 25); // Much more forgiving tolerance
        }

        function updateOutlineCoverage() {
            // COMPREHENSIVE outline coverage checking - player must drag across entire outline!
            if (!gameState.cookieOutlines || !gameState.selectedCookie) {
                gameState.traceProgress = 0;
                    return;
                }

            const outlineData = gameState.cookieOutlines[gameState.selectedCookie];
            if (!outlineData || !outlineData.edgePixels || outlineData.edgePixels.length === 0) {
                gameState.traceProgress = 0;
                return;
            }
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const size = 300;
            
            // Scale factors to convert image coordinates to game coordinates
            const scaleX = size / outlineData.width;
            const scaleY = size / outlineData.height;
            
            let coveredOutlinePoints = 0;
            const tolerance = 20; // How close the trace must be to outline points
            
            // For each outline point, check if it has been covered by tracing
            for (let outlinePoint of outlineData.edgePixels) {
                // Convert outline point to game coordinates
                const gameX = centerX + (outlinePoint.x - outlineData.width/2) * scaleX;
                const gameY = centerY + (outlinePoint.y - outlineData.height/2) * scaleY;
                
                // Check if any trace point is close to this outline point
                let pointCovered = false;
                for (let tracePoint of gameState.tracePath) {
                    const distance = Math.sqrt(
                        (tracePoint.x - gameX) ** 2 + 
                        (tracePoint.y - gameY) ** 2
                    );
                    
                    if (distance <= tolerance) {
                        pointCovered = true;
                        break;
                    }
                }
                
                if (pointCovered) {
                    coveredOutlinePoints++;
                }
            }
            
            // Progress = percentage of outline points that have been traced over
            gameState.traceProgress = coveredOutlinePoints / outlineData.edgePixels.length;
            
            console.log(`ðŸ” Outline Coverage: ${coveredOutlinePoints}/${outlineData.edgePixels.length} points (${Math.floor(gameState.traceProgress * 100)}%)`);
        }

        // getRequiredPathLength function removed - now using actual outline coverage instead

        // Shell Game Cookie Challenge Complete!

        function handleMouseUp(e) {
            // Prevent any input while death video is playing
            const deathVideoContainer = document.getElementById('deathVideoContainer');
            if (deathVideoContainer && deathVideoContainer.style.display === 'block') {
                e.preventDefault();
                return;
            }
            
            // Ignore input if game is paused (during money falling)
            if (gameState.isPaused) return;
            
            gameState.isMouseDown = false; // Track mouse up
            
            // Handle marble shooting
            if (currentScene === 'marbles' && gameState.isAiming && gameState.marblesLeft > 0) {
                const rect = canvas.getBoundingClientRect();
                const endX = e.clientX - rect.left;
                const endY = e.clientY - rect.top;
                
                // Calculate power and direction
                const dx = gameState.aimStartX - endX;
                const dy = gameState.aimStartY - endY;
                const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.15, 20);
                
                // Create marble
                gameState.marbles.push({
                    x: gameState.aimStartX,
                    y: gameState.aimStartY,
                    vx: dx * 0.15,
                    vy: dy * 0.15,
                    active: true
                });
                
                gameState.marblesLeft--;
                gameState.isAiming = false;
                
                // Play marble shooting sound
                initAudioContext();
                createBeep(400, 0.1, 'sine');
            }
            
            // Handle mouse up events for tracing
            if (currentScene === 'honeycomb' && gameState.shellGamePhase === 5) {
                gameState.tracingActive = false;
                gameState.tracingStarted = false;
            }
        }

        // Event Listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);

        // Game Initialization
        function initGame() {
            console.log('ðŸŽ® Alpha Games v1.5.0 - 40s timer, more boxes update');
            console.log('Build date: 2025-08-17');
            loadBackgroundMusic();
        showScene('mainMenu');
            render();
        }

        // Start the game
        loadAssets();
    </script>
</body>
</html>
